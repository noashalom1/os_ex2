        -:    0:Source:drinks_bar.cpp
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:5
        -:    1:#include <iostream>
        -:    2:#include <string>
        -:    3:#include <map>
        -:    4:#include <vector>
        -:    5:#include <sstream>
        -:    6:#include <algorithm>
        -:    7:#include <unistd.h>
        -:    8:#include <cstring>
        -:    9:#include <netinet/in.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/select.h>
        -:   12:#include <climits>
        -:   13:#include <cstdlib>
        -:   14:#include <csignal>  // for the signals 
        -:   15:#include <cstdlib>  // exit()
        -:   16:#include <sys/un.h>
        -:   17:
        -:   18:#define MAX_VALUE 1000000000000000000
        -:   19:using namespace std;
        -:   20:#define UNIX_STREAM_PATH "/tmp/drinks_bar_stream.sock"
        -:   21:#define UNIX_DGRAM_PATH "/tmp/drinks_bar_dgram.sock"
        -:   22:
        -:   23:bool history_path = false;
        -:   24:const char* path = "default_data.txt";
        -:   25:
        -:   26:/**
        -:   27: * @brief Handles SIGINT (Ctrl+C) signal and exits cleanly.
        -:   28: */
function _Z13handle_siginti called 1 returned 0% blocks executed 100%
        1:   29:void handle_sigint([[maybe_unused]] int sig) {
        1:   30:    cout << "\nðŸ“¤ Caught SIGINT (Ctrl+C). Exiting cleanly...\n";
call    0 returned 100%
        1:   31:    exit(0);  // makes the .gcda 
        -:   32:}
        -:   33:
        -:   34:/**
        -:   35: * @struct file_storage
        -:   36: * @brief Represents storage format for atom quantities in a binary file.
        -:   37: */
        -:   38:typedef struct f{
        -:   39:    unsigned long long carbon;
        -:   40:    unsigned long long oxygen;
        -:   41:    unsigned long long hydrogen;
        -:   42:} file_storage;
        -:   43:
        -:   44:// Global atom and molecule inventories
        -:   45:map<string, unsigned long long> atom_inventory = {
        -:   46:    {"CARBON", 0}, {"OXYGEN", 0}, {"HYDROGEN", 0}
        -:   47:};
        -:   48:
        -:   49:// Predefined molecule compositions
        -:   50:map<string, map<string, int>> molecule_recipes = {
        -:   51:    {"WATER", {{"HYDROGEN", 2}, {"OXYGEN", 1}}},
        -:   52:    {"CARBON DIOXIDE", {{"CARBON", 1}, {"OXYGEN", 2}}},
        -:   53:    {"ALCOHOL", {{"CARBON", 2}, {"HYDROGEN", 6}, {"OXYGEN", 1}}},
        -:   54:    {"GLUCOSE", {{"CARBON", 6}, {"HYDROGEN", 12}, {"OXYGEN", 6}}}
        -:   55:};
        -:   56:
        -:   57:// Drink recipes built from molecules
        -:   58:map<string, vector<string>> drink_recipes = {
        -:   59:    {"SOFT DRINK", {"WATER", "CARBON DIOXIDE", "GLUCOSE"}},
        -:   60:    {"VODKA", {"WATER", "ALCOHOL", "GLUCOSE"}},
        -:   61:    {"CHAMPAGNE", {"WATER", "CARBON DIOXIDE", "ALCOHOL"}}
        -:   62:};
        -:   63:
        -:   64:map<string, unsigned long long> molecule_inventory;
        -:   65:
        -:   66:/**
        -:   67: * @brief Prints the current inventory of atoms.
        -:   68: */
function _Z15print_inventoryv called 27 returned 100% blocks executed 61%
       27:   69:void print_inventory() {
       54:   70:    cout << "CARBON: " << atom_inventory["CARBON"]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 never executed
       81:   71:         << ", OXYGEN: " << atom_inventory["OXYGEN"]
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 never executed
       81:   72:         << ", HYDROGEN: " << atom_inventory["HYDROGEN"] << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 never executed
       27:   73:}
        -:   74:
        -:   75:/**
        -:   76: * @brief Adds a specified count of molecules to the molecule inventory.
        -:   77: */
function _Z26add_molecules_to_inventoryRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEy called 10 returned 100% blocks executed 100%
       10:   78:void add_molecules_to_inventory(const string& molecule_name, unsigned long long count) {
       10:   79:    molecule_inventory[molecule_name] += count;
call    0 returned 100%
       10:   80:}
        -:   81:
        -:   82:/**
        -:   83: * @brief Reads the atom inventory from a binary file.
        -:   84: */
function _Z14read_from_filev called 61 returned 100% blocks executed 38%
       61:   85:void read_from_file(){
        -:   86:    file_storage fs;
       61:   87:    FILE* f = fopen(path, "rb");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       61:   88:    if (f != nullptr) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
       56:   89:        fread(&fs, sizeof(fs), 1, f);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       56:   90:        fclose(f);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   91:    } else {
        5:   92:        perror("Error reading from file");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5:   93:        return;
        -:   94:    }
     392*:   95:    if(atom_inventory["CARBON"] != fs.carbon || atom_inventory["HYDROGEN"] != fs.hydrogen || atom_inventory["OXYGEN"] != fs.oxygen ){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
call   11 returned 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0% (throw)
branch 14 taken 100% (fallthrough)
branch 15 taken 0%
call   16 returned 100%
branch 17 taken 100% (fallthrough)
branch 18 taken 0% (throw)
call   19 returned 100%
branch 20 taken 100% (fallthrough)
branch 21 taken 0% (throw)
branch 22 taken 0% (fallthrough)
branch 23 taken 100%
branch 24 taken 100% (fallthrough)
branch 25 taken 0%
call   26 returned 100%
branch 27 taken 100% (fallthrough)
branch 28 taken 0%
branch 29 taken 100% (fallthrough)
branch 30 taken 0%
call   31 returned 100%
branch 32 taken 100% (fallthrough)
branch 33 taken 0%
branch 34 taken 100% (fallthrough)
branch 35 taken 0%
call   36 returned 100%
branch 37 taken 100% (fallthrough)
branch 38 taken 0%
branch 39 taken 0% (fallthrough)
branch 40 taken 100%
branch 41 never executed (fallthrough)
branch 42 never executed
call   43 never executed
branch 44 never executed (fallthrough)
branch 45 never executed
branch 46 never executed (fallthrough)
branch 47 never executed
call   48 never executed
branch 49 never executed (fallthrough)
branch 50 never executed
branch 51 never executed (fallthrough)
branch 52 never executed
call   53 never executed
branch 54 never executed (fallthrough)
branch 55 never executed
    #####:   96:        atom_inventory["CARBON"] = fs.carbon;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
    #####:   97:        atom_inventory["HYDROGEN"] = fs.hydrogen;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
    #####:   98:        atom_inventory["OXYGEN"] = fs.oxygen;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
    #####:   99:        cout << "Update from file: ";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  100:        print_inventory();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  101:    }
        -:  102:}
        -:  103:
        -:  104:/**
        -:  105: * @brief Updates the binary file with current atom inventory.
        -:  106: * 
        -:  107: * @param fs The file_storage struct with current atom values.
        -:  108: */
function _Z11update_file1f called 23 returned 100% blocks executed 83%
       23:  109:void update_file(file_storage fs){
       23:  110:    FILE* f = fopen(path, "wb");
call    0 returned 100%
       23:  111:    if (f != nullptr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       23:  112:        fwrite(&fs, sizeof(fs), 1, f);
call    0 returned 100%
       23:  113:        fclose(f);
call    0 returned 100%
        -:  114:    } else {
    #####:  115:        perror("Error opening file for writing");
call    0 never executed
        -:  116:    }
       23:  117:}
        -:  118:
        -:  119:/**
        -:  120: * @brief Adds a given amount of atoms to the inventory if valid.
        -:  121: * @param atom_type The type of atom to add (CARBON, OXYGEN, HYDROGEN).
        -:  122: * @param amount_string The amount as a string (validated and converted).
        -:  123: */
function _Z9add_atomsRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 16 returned 100% blocks executed 62%
       16:  124:void add_atoms(const string& atom_type, const string& amount_string) {
       16:  125:    if (!all_of(amount_string.begin(), amount_string.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 25% (fallthrough)
branch  6 taken 75%
        4:  126:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        4:  127:        return;
        -:  128:    }
        -:  129:
        -:  130:    try {
       12:  131:        unsigned long long amount = stoull(amount_string);  
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25% (throw)
        9:  132:        if (atom_inventory[atom_type] + amount > MAX_VALUE) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  133:            cerr << "Invalid command: not enough place for the atoms!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  134:            return;
        -:  135:        }
        -:  136:
        9:  137:        atom_inventory[atom_type] += amount;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  138:    } catch (const exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        3:  139:        cerr << "Error converting number" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        3:  140:    }
call    0 returned 100%
call    1 never executed
        -:  141:
        -:  142:    file_storage fs;
       24:  143:    fs.carbon = atom_inventory["CARBON"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       24:  144:    fs.hydrogen = atom_inventory["HYDROGEN"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       12:  145:    fs.oxygen = atom_inventory["OXYGEN"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  146:
       12:  147:    update_file(fs);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  148:}
        -:  149:
        -:  150:/**
        -:  151: * @brief Converts timeout string to integer seconds.
        -:  152: * @param timeout Timeout as string.
        -:  153: * @return Timeout in seconds.
        -:  154: */
function _Z11set_timeoutRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 44%
        3:  155:int set_timeout(const string& timeout) {
        3:  156:    if (!all_of(timeout.begin(), timeout.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  157:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 never executed
call    1 never executed
    #####:  158:        return 0;
        -:  159:    }
        -:  160:
        -:  161:    try {
        3:  162:        int time = stoull(timeout); 
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  163:        return time;
    =====:  164:    } catch (const exception& e) {
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    =====:  165:        cerr << "Error converting number" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    =====:  166:        return 0;
    =====:  167:    }
call    0 never executed
call    1 never executed
        -:  168:}
        -:  169:
        -:  170:/**
        -:  171: * @brief Creates and listens on a UNIX domain stream socket.
        -:  172: *
        -:  173: * Unlinks the existing socket file, creates a new stream socket,
        -:  174: * binds it to UNIX_STREAM_PATH, and starts listening.
        -:  175: *
        -:  176: * @return Socket file descriptor on success, exits on failure.
        -:  177: */
function _Z25create_unix_stream_socketv called 0 returned 0% blocks executed 0%
    #####:  178:int create_unix_stream_socket() {
    #####:  179:    unlink(UNIX_STREAM_PATH); // Remove existing socket file
call    0 never executed
    #####:  180:    int sock = socket(AF_UNIX, SOCK_STREAM, 0); // Create UNIX stream socket
call    0 never executed
    #####:  181:    if (sock < 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  182:        perror("UDS STREAM socket");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  183:        exit(1);
call    0 never executed
        -:  184:    }
    #####:  185:    sockaddr_un addr{};
    #####:  186:    addr.sun_family = AF_UNIX;
    #####:  187:    strncpy(addr.sun_path, UNIX_STREAM_PATH, sizeof(addr.sun_path) - 1); // Set socket path
    #####:  188:    bind(sock, (sockaddr*)&addr, sizeof(addr)); // Bind socket
call    0 never executed
    #####:  189:    listen(sock, 5); // Listen for connections
call    0 never executed
    #####:  190:    return sock;
        -:  191:}
        -:  192:
        -:  193:/**
        -:  194: * @brief Creates and binds a UNIX domain datagram socket.
        -:  195: *
        -:  196: * Unlinks the existing datagram socket file, creates a new one,
        -:  197: * and binds it to UNIX_DGRAM_PATH.
        -:  198: *
        -:  199: * @return Socket file descriptor on success, exits on failure.
        -:  200: */
function _Z24create_unix_dgram_socketv called 0 returned 0% blocks executed 0%
    #####:  201:int create_unix_dgram_socket() {
    #####:  202:    unlink(UNIX_DGRAM_PATH);  // Remove existing socket file
call    0 never executed
    #####:  203:    int sock = socket(AF_UNIX, SOCK_DGRAM, 0); // Create UNIX datagram socket
call    0 never executed
    #####:  204:    if (sock < 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  205:        perror("UDS DGRAM socket");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  206:        exit(1);
call    0 never executed
        -:  207:    }
    #####:  208:    sockaddr_un addr{};
    #####:  209:    addr.sun_family = AF_UNIX;
    #####:  210:    strncpy(addr.sun_path, UNIX_DGRAM_PATH, sizeof(addr.sun_path) - 1);  // Set socket path
    #####:  211:    bind(sock, (sockaddr*)&addr, sizeof(addr)); // Bind socket
call    0 never executed
    #####:  212:    return sock;
        -:  213:}
        -:  214:
        -:  215:/**
        -:  216: * @brief Processes a TCP command to add atoms.
        -:  217: *
        -:  218: * Parses a TCP command of the form "ADD <ATOM> <AMOUNT>", 
        -:  219: * validates it, updates inventory, and prints the result.
        -:  220: *
        -:  221: * @param command The TCP command string.
        -:  222: */
function _Z18handle_tcp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 28 returned 100% blocks executed 77%
       28:  223:void handle_tcp_command(const string& command) {
       28:  224:    read_from_file();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       28:  225:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       28:  226:    string action, atom, amount_string;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  227:
       28:  228:    iss >> action >> atom >> amount_string;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
       28:  229:    transform(atom.begin(), atom.end(), atom.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  230:
       28:  231:    if (action != "ADD" || atom_inventory.find(atom) == atom_inventory.end() || iss.fail()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 79% (fallthrough)
branch  4 taken 21%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 77% (fallthrough)
branch 11 taken 23%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
branch 15 taken 6% (fallthrough)
branch 16 taken 94%
branch 17 taken 43% (fallthrough)
branch 18 taken 57%
       12:  232:        cerr << "Invalid TCP command!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
       12:  233:        return;
        -:  234:    }
        -:  235:
        -:  236:    // detect extra arguments
       16:  237:    string extra; 
call    0 returned 100%
       16:  238:    if (iss >> extra) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####:  239:        cerr << "Invalid command: too many arguments!" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  240:        return;
        -:  241:    }
        -:  242:
       16:  243:    add_atoms(atom, amount_string);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       16:  244:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       64:  245:}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 57% (fallthrough)
branch  5 taken 43%
call    6 returned 100%
branch  7 taken 57% (fallthrough)
branch  8 taken 43%
call    9 returned 100%
branch 10 taken 57% (fallthrough)
branch 11 taken 43%
call   12 returned 100%
branch 13 taken 57% (fallthrough)
branch 14 taken 43%
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  246:
        -:  247:/**
        -:  248: * @brief Handles UDP command to deliver molecules.
        -:  249: * @param command The full command string.
        -:  250: * @return Response to be sent back to the client.
        -:  251: */
function _Z18handle_udp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 30 returned 100% blocks executed 67%
       30:  252:string handle_udp_command(const string& command) {
       30:  253:    read_from_file();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       30:  254:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       30:  255:    string action;
call    0 returned 100%
       30:  256:    iss >> action;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  257:
       30:  258:    if (action != "DELIVER") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 20% (fallthrough)
branch  4 taken 80%
       12:  259:        return "ERROR: Invalid command";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  260:    }
        -:  261:
       24:  262:    vector<string> tokens;
call    0 returned 100%
       24:  263:    string token;
call    0 returned 100%
       71:  264:    while (iss >> token) tokens.push_back(token);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 66%
branch 10 taken 34% (fallthrough)
        -:  265:
       30:  266:    if (tokens.size() < 2) return "ERROR: Invalid command format";
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  267:
        -:  268:  
       21:  269:    string count_str = tokens.back();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  270:
       21:  271:    if (!all_of(count_str.begin(), count_str.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 14% (fallthrough)
branch  6 taken 86%
        6:  272:        return "ERROR: Not a positive number";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  273:    }
        -:  274:
        -:  275:    unsigned long long count;
        -:  276:    try {
       18:  277:        count = stoull(count_str);
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11% (throw)
        2:  278:    } catch (const exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        2:  279:        return "ERROR: Conversion failed";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  280:    }
call    0 returned 100%
call    1 never executed
        -:  281:
       16:  282:    string molecule_name;
call    0 returned 100%
       36:  283:    for (size_t i = 0; i < tokens.size() - 1; ++i) {
call    0 returned 100%
branch  1 taken 56%
branch  2 taken 44% (fallthrough)
       20:  284:        if (!molecule_name.empty()) molecule_name += " ";
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
       20:  285:        molecule_name += tokens[i];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  286:    }
        -:  287:
       16:  288:    if (molecule_recipes.find(molecule_name) == molecule_recipes.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 12% (fallthrough)
branch  6 taken 88%
        2:  289:        return "ERROR: Unknown molecule '" + molecule_name + "'";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  290:    }
        -:  291:
       14:  292:    const auto& recipe = molecule_recipes[molecule_name];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  293:    map<string, unsigned long long> needed;
call    0 returned 100%
       48:  294:    for (const auto& [atom, per_mol] : recipe) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       34:  295:        needed[atom] += per_mol * count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  296:    }
        -:  297:
       40:  298:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 75%
branch  8 taken 25% (fallthrough)
       30:  299:        if (atom_inventory[atom] < need_count) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 13% (fallthrough)
branch  4 taken 87%
        4:  300:            return "ERROR: Not enough atoms â€“ missing " + to_string(need_count - atom_inventory[atom]) + " " + atom;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 never executed
call   19 never executed
call   20 never executed
        -:  301:        }
        -:  302:    }
        -:  303:    
       34:  304:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       24:  305:        atom_inventory[atom] -= need_count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  306:    }
        -:  307:
        -:  308:    file_storage fs;
       20:  309:    fs.carbon = atom_inventory["CARBON"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       20:  310:    fs.hydrogen = atom_inventory["HYDROGEN"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       10:  311:    fs.oxygen = atom_inventory["OXYGEN"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       10:  312:    update_file(fs);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  313:
       10:  314:    cout << "DELIVERED: " << count << " " << molecule_name << " molecules" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
       10:  315:    add_molecules_to_inventory(molecule_name, count);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:  316:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:  317:    return "OK: Delivered " + to_string(count) + " " + molecule_name + " molecules";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
        -:  318:
       30:  319:}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
        -:  320:
        -:  321:/**
        -:  322: * @brief Computes how many full drinks of a type can be prepared with available atoms.
        -:  323: * @param drink_name The name of the drink (e.g., "VODKA").
        -:  324: * @return Number of drinks that can be prepared.
        -:  325: */
function _Z19compute_drink_countRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 63%
        3:  326:unsigned long long compute_drink_count(const string& drink_name) {
        -:  327:    // Required atom counts for one drink
        3:  328:    unsigned long long needed_carbon = 0;
        3:  329:    unsigned long long needed_hydrogen = 0;
        3:  330:    unsigned long long needed_oxygen = 0;
        -:  331:
        3:  332:    if (drink_name == "SOFT DRINK") {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  333:        // Contains: WATER (H2O), CARBON DIOXIDE (CO2), GLUCOSE (C6H12O6)
        1:  334:        needed_carbon = 1 + 6;           // 1 from CO2, 6 from GLUCOSE
        1:  335:        needed_hydrogen = 2 + 12;        // 2 from WATER, 12 from GLUCOSE
        1:  336:        needed_oxygen = 1 + 2 + 6;       // 1 from WATER, 2 from CO2, 6 from GLUCOSE
        2:  337:    } else if (drink_name == "VODKA") {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  338:        // Contains: WATER, ALCOHOL (C2H6O), GLUCOSE
        1:  339:        needed_carbon = 2 + 6;           // 2 from ALCOHOL, 6 from GLUCOSE
        1:  340:        needed_hydrogen = 2 + 6 + 12;    // 2 from WATER, 6 from ALCOHOL, 12 from GLUCOSE
        1:  341:        needed_oxygen = 1 + 1 + 6;       // 1 from WATER, 1 from ALCOHOL, 6 from GLUCOSE
        1:  342:    } else if (drink_name == "CHAMPAGNE") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  343:        // Contains: WATER, CO2, ALCOHOL
        1:  344:        needed_carbon = 1 + 2;           // 1 from CO2, 2 from ALCOHOL
        1:  345:        needed_hydrogen = 2 + 6;         // 2 from WATER, 6 from ALCOHOL
        1:  346:        needed_oxygen = 1 + 2 + 1;       // 1 from WATER, 2 from CO2, 1 from ALCOHOL
        -:  347:    } else {
        -:  348:        // Drink not recognized
    #####:  349:        return 0;
        -:  350:    }
        -:  351:
        -:  352:    // Calculate how many full drinks can be made based on current atom inventory
        6:  353:    unsigned long long from_carbon = atom_inventory["CARBON"] / needed_carbon;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        6:  354:    unsigned long long from_hydrogen = atom_inventory["HYDROGEN"] / needed_hydrogen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        3:  355:    unsigned long long from_oxygen = atom_inventory["OXYGEN"] / needed_oxygen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        -:  356:
        -:  357:    // The limiting atom determines the maximum number of drinks possible
        3:  358:    return std::min({from_carbon, from_hydrogen, from_oxygen});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  359:}
        -:  360:
function main called 5 returned 80% blocks executed 59%
        5:  361:int main(int argc, char* argv[]) {
        5:  362:    signal(SIGINT, handle_sigint);  // Catch Ctrl+C
call    0 returned 100%
        5:  363:    int tcp_port = -1, udp_port = -1;
        5:  364:    int timeout = -1;
        -:  365:    int opt;
        5:  366:    string stream_path, dgram_path;
call    0 returned 100%
call    1 returned 100%
        -:  367:    const char *oxygen;
        -:  368:    const char *carbon;
        -:  369:    const char *hydrogen;
        5:  370:    bool o = false, c = false, h = false;
        -:  371:
       32:  372:    while ((opt = getopt(argc, argv, "T:U:o:c:h:t:s:d:f:")) != -1) {
call    0 returned 100%
branch  1 taken 88%
branch  2 taken 12% (fallthrough)
       28:  373:        switch (opt) {
branch  0 taken 11%
branch  1 taken 11%
branch  2 taken 11%
branch  3 taken 11%
branch  4 taken 11%
branch  5 taken 11%
branch  6 taken 11%
branch  7 taken 11%
branch  8 taken 11%
branch  9 taken 4%
        3:  374:            case 'T': tcp_port = atoi(optarg); break;
        3:  375:            case 'U': udp_port = atoi(optarg); break;
        3:  376:            case 'o': oxygen = optarg; o = true; break;
        3:  377:            case 'c': carbon = optarg; c = true; break;
        3:  378:            case 'h': hydrogen = optarg; h = true; break;
        9:  379:            case 't': timeout = set_timeout(string(optarg)); break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        3:  380:            case 's': stream_path = optarg; break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  381:            case 'd': dgram_path = optarg; break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  382:            case 'f': path = optarg; history_path = true; break;
        1:  383:            default:
        1:  384:                cerr << "Usage: ./drinks_bar -T <tcp_port> -U <udp_port> [-o num] [-c num] [-h num] [-t timeout]" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  385:                return 1;
        -:  386:        }
        -:  387:    }
        -:  388:    
        4:  389:    if(history_path){
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        3:  390:        read_from_file();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  391:    }else{
        1:  392:        if(c){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  393:            add_atoms("CARBON", carbon);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
        -:  394:        }
        1:  395:        if(o){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  396:            add_atoms("OXYGEN", oxygen);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
        -:  397:        }
        1:  398:        if(h){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  399:            add_atoms("HYDROGEN", hydrogen);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
        -:  400:        }
        -:  401:        file_storage fs;
        2:  402:        fs.carbon = atom_inventory["CARBON"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        2:  403:        fs.hydrogen = atom_inventory["HYDROGEN"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        1:  404:        fs.oxygen = atom_inventory["OXYGEN"];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        1:  405:        update_file(fs);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  406:    }
        -:  407:
        4:  408:    if (tcp_port == -1 || udp_port == -1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        3:  409:        cerr << "ERROR: TCP and UDP ports are required (use -T and -U)" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        3:  410:        return 1;
        -:  411:    }
        -:  412:    
        -:  413:    fd_set master, read_fds;
       17:  414:    FD_ZERO(&master);
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        1:  415:    int uds_stream_sock = -1, uds_dgram_sock = -1;
        1:  416:    int fdmax = STDIN_FILENO;
        -:  417:
        1:  418:    if (!stream_path.empty()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:  419:        unlink(stream_path.c_str());
call    0 returned 100%
call    1 returned 100%
        1:  420:        uds_stream_sock = socket(AF_UNIX, SOCK_STREAM, 0);
call    0 returned 100%
        1:  421:        sockaddr_un addr{};
        1:  422:        addr.sun_family = AF_UNIX;
        1:  423:        strncpy(addr.sun_path, stream_path.c_str(), sizeof(addr.sun_path) - 1);
call    0 returned 100%
        1:  424:        bind(uds_stream_sock, (sockaddr*)&addr, sizeof(addr));
call    0 returned 100%
        1:  425:        listen(uds_stream_sock, 5);
call    0 returned 100%
        1:  426:        if (uds_stream_sock != -1) FD_SET(uds_stream_sock, &master);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       1*:  427:        if (uds_dgram_sock != -1) FD_SET(uds_dgram_sock, &master);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  428:
        1:  429:        fdmax = max(fdmax, uds_stream_sock);
call    0 returned 100%
        1:  430:        cout << "Listening on UDS stream: " << stream_path << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  431:    }
        -:  432:
        1:  433:    if (!dgram_path.empty()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:  434:        unlink(dgram_path.c_str());
call    0 returned 100%
call    1 returned 100%
        1:  435:        uds_dgram_sock = socket(AF_UNIX, SOCK_DGRAM, 0);
call    0 returned 100%
        1:  436:        sockaddr_un addr{};
        1:  437:        addr.sun_family = AF_UNIX;
        1:  438:        strncpy(addr.sun_path, dgram_path.c_str(), sizeof(addr.sun_path) - 1);
call    0 returned 100%
        1:  439:        bind(uds_dgram_sock, (sockaddr*)&addr, sizeof(addr));
call    0 returned 100%
        1:  440:        if (uds_stream_sock != -1) fdmax = max(fdmax, uds_stream_sock);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        1:  441:        if (uds_dgram_sock != -1) fdmax = max(fdmax, uds_dgram_sock);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  442:
        1:  443:        fdmax = max(fdmax, uds_dgram_sock);
call    0 returned 100%
        1:  444:        cout << "Listening on UDS datagram: " << dgram_path << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  445:    }
        -:  446:
        -:  447:
        1:  448:    int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
call    0 returned 100%
        1:  449:    sockaddr_in tcp_addr{};
        1:  450:    tcp_addr.sin_family = AF_INET;
        1:  451:    tcp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  452:    tcp_addr.sin_port = htons(tcp_port);
        1:  453:    if (bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr)) < 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  454:    perror("bind TCP");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  455:    return 1;
        -:  456:    }
        -:  457:
        1:  458:    listen(tcp_sock, 5);
call    0 returned 100%
        -:  459:
        1:  460:    int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
call    0 returned 100%
        1:  461:    sockaddr_in udp_addr{};
        1:  462:    udp_addr.sin_family = AF_INET;
        1:  463:    udp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  464:    udp_addr.sin_port = htons(udp_port);
        1:  465:    if(bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr)) < 0){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  466:        perror("bind UDP");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  467:        return 1;
        -:  468:    }
        -:  469:
        1:  470:    cout << "bar_drinks running on TCP port " << tcp_port
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  471:         << " and UDP port " << udp_port << "..." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        -:  472:    
        1:  473:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  474:
        1:  475:    FD_SET(tcp_sock, &master);
        1:  476:    FD_SET(udp_sock, &master);
        1:  477:    FD_SET(STDIN_FILENO, &master);
        1:  478:    fdmax = max({tcp_sock, udp_sock, STDIN_FILENO});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  479:    FD_SET(uds_stream_sock, &master);
        1:  480:    FD_SET(uds_dgram_sock, &master);
        1:  481:    fdmax = max({fdmax, uds_stream_sock, uds_dgram_sock});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  482:
        -:  483:
        1:  484:    timeval* timeout_ptr = nullptr;
        1:  485:    timeval timeout_val{};
        1:  486:    if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  487:        timeout_val.tv_sec = timeout;
        1:  488:        timeout_val.tv_usec = 0;
        1:  489:        timeout_ptr = &timeout_val;
        -:  490:    }
        -:  491:
       1*:  492:    vector<int> clients;
call    0 returned 100%
call    1 never executed
        -:  493:
        -:  494:    while (true) {
       77:  495:        read_fds = master;
       77:  496:        int activity = select(fdmax + 1, &read_fds, nullptr, nullptr, timeout_ptr);
call    0 returned 99%
branch  1 taken 99% (fallthrough)
branch  2 taken 0% (throw)
       76:  497:        if (activity < 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  498:            perror("select");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  499:            break;
       76:  500:        } else if (activity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  501:            cout << "Timeout reached with no activity. Server exiting." << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  502:            break;
        -:  503:        }
        -:  504:
      684:  505:        for (int i = 0; i <= fdmax; ++i) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
      608:  506:            if (!FD_ISSET(i, &read_fds)) continue;
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
       76:  507:                        else if (i == uds_stream_sock) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  508:                int newfd = accept(uds_stream_sock, nullptr, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  509:                if (newfd >= 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  510:                    FD_SET(newfd, &master);
       1*:  511:                    if (newfd > fdmax) fdmax = newfd;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        1:  512:                    clients.push_back(newfd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  513:                    if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  514:                        timeout_val.tv_sec = timeout;
        1:  515:                        timeout_val.tv_usec = 0;
        1:  516:                        timeout_ptr = &timeout_val;
        -:  517:                    }
        -:  518:                }
       75:  519:            } else if (i == uds_dgram_sock) {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
       10:  520:                char buf[1024] = {0};
       10:  521:                sockaddr_un client_addr{};
       10:  522:                socklen_t len = sizeof(client_addr);
       10:  523:                int n = recvfrom(uds_dgram_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       10:  524:                if (n > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  525:                    string response = handle_udp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       10:  526:                    if (response.rfind("ERROR", 0) == 0) cerr << response << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 60% (fallthrough)
branch  4 taken 40%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
       10:  527:                    sendto(uds_dgram_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       10:  528:                    if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  529:                        timeout_val.tv_sec = timeout;
       10:  530:                        timeout_val.tv_usec = 0;
       10:  531:                        timeout_ptr = &timeout_val;
        -:  532:                    }
       10:  533:                }
call    0 returned 100%
call    1 never executed
        -:  534:            }
        -:  535:
       65:  536:            else if (i == tcp_sock) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        2:  537:                int newfd = accept(tcp_sock, nullptr, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  538:                FD_SET(newfd, &master);
        2:  539:                if (newfd > fdmax) fdmax = newfd;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  540:                clients.push_back(newfd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  541:                if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  542:                timeout_val.tv_sec = timeout;
        2:  543:                timeout_val.tv_usec = 0;
        2:  544:                timeout_ptr = &timeout_val;
        -:  545:                }
       63:  546:            } else if (i == udp_sock) {
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
       20:  547:                char buf[1024] = {0};
       20:  548:                sockaddr_in client_addr{};
       20:  549:                socklen_t len = sizeof(client_addr);
       20:  550:                int n = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       20:  551:                if (n > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       20:  552:                    string response = handle_udp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       20:  553:                    if (response.rfind("ERROR", 0) == 0) cerr << response << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 70% (fallthrough)
branch  4 taken 30%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
       20:  554:                    sendto(udp_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       20:  555:                    if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       20:  556:                    timeout_val.tv_sec = timeout;
       20:  557:                    timeout_val.tv_usec = 0;
       20:  558:                    timeout_ptr = &timeout_val;
        -:  559:                    }
       20:  560:                }
call    0 returned 100%
call    1 never executed
       43:  561:            } else if (i == STDIN_FILENO) {
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
       12:  562:                string line;
call    0 returned 100%
       12:  563:                getline(cin, line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  564:                transform(line.begin(), line.end(), line.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       12:  565:                istringstream iss(line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  566:                string command, drink;
call    0 returned 100%
call    1 returned 100%
       12:  567:                iss >> command;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  568:                getline(iss, drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  569:                drink.erase(0, drink.find_first_not_of(" "));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       12:  570:                transform(command.begin(), command.end(), command.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       12:  571:                transform(drink.begin(), drink.end(), drink.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       12:  572:                if (command == "GEN" && drink_recipes.find(drink) != drink_recipes.end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 67% (fallthrough)
branch  4 taken 33%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 38% (fallthrough)
branch 11 taken 62%
branch 12 taken 25% (fallthrough)
branch 13 taken 75%
        3:  573:                    unsigned long long count = compute_drink_count(drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  574:                    cout << "Can prepare " << count << " " << drink << " drinks" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
        -:  575:                } else {
        9:  576:                    cout << "Unknown drink command: " << line << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  577:                }
       12:  578:                if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:  579:                timeout_val.tv_sec = timeout;
       12:  580:                timeout_val.tv_usec = 0;
       12:  581:                timeout_ptr = &timeout_val;
        -:  582:                }
       12:  583:            } else {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
       31:  584:                char buf[1024] = {0};
       31:  585:                int n = recv(i, buf, sizeof(buf) - 1, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       31:  586:                if (n <= 0) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        3:  587:                    close(i);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  588:                    FD_CLR(i, &master);
        -:  589:                } else {
       28:  590:                    handle_tcp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       28:  591:                    if (timeout > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       28:  592:                    timeout_val.tv_sec = timeout;
       28:  593:                    timeout_val.tv_usec = 0;
       28:  594:                    timeout_ptr = &timeout_val;
        -:  595:                    }
        -:  596:                }
        -:  597:            }
        -:  598:        }
       76:  599:    }
    #####:  600:    if (uds_stream_sock != -1) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  601:    close(uds_stream_sock);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  602:    unlink(stream_path.c_str());
call    0 never executed
call    1 never executed
        -:  603:    }
    #####:  604:    if (uds_dgram_sock != -1) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  605:        close(uds_dgram_sock);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  606:        unlink(dgram_path.c_str());
call    0 never executed
call    1 never executed
        -:  607:    }
        -:  608:
    #####:  609:    close(tcp_sock);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  610:    close(udp_sock);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:  611:
        -:  612:
    #####:  613:    return 0;
call    0 never executed
        4:  614:}
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
