        -:    0:Source:drinks_bar.cpp
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:3
        -:    1:#include <iostream>
        -:    2:#include <string>
        -:    3:#include <map>
        -:    4:#include <vector>
        -:    5:#include <sstream>
        -:    6:#include <algorithm>
        -:    7:#include <unistd.h>
        -:    8:#include <cstring>
        -:    9:#include <netinet/in.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/select.h>
        -:   12:#include <climits>
        -:   13:#include <termios.h>
        -:   14:#include <csignal>  // for the signals 
        -:   15:#include <cstdlib>  // exit()
        -:   16:#define MAX_VALUE 1000000000000000000
        -:   17:using namespace std;
        -:   18:
        -:   19:/**
        -:   20: * @brief Handles SIGINT (Ctrl+C) signal and exits cleanly.
        -:   21: */
function _Z13handle_siginti called 1 returned 0% blocks executed 100%
        1:   22:void handle_sigint([[maybe_unused]] int sig) {
        1:   23:    cout << "\nðŸ“¤ Caught SIGINT (Ctrl+C). Exiting cleanly...\n";
call    0 returned 100%
        1:   24:    exit(0);  // makes the .gcda 
        -:   25:}
        -:   26:
        -:   27:// Global inventory for atoms (Carbon, Oxygen, Hydrogen)
        -:   28:map<string, unsigned long long> atom_inventory = {
        -:   29:    {"CARBON", 0}, {"OXYGEN", 0}, {"HYDROGEN", 0}
        -:   30:};
        -:   31:
        -:   32:// Molecule recipes: how many atoms of each type needed per molecule
        -:   33:map<string, map<string, int>> molecule_recipes = {
        -:   34:    {"WATER", {{"HYDROGEN", 2}, {"OXYGEN", 1}}},
        -:   35:    {"CARBON DIOXIDE", {{"CARBON", 1}, {"OXYGEN", 2}}},
        -:   36:    {"ALCOHOL", {{"CARBON", 2}, {"HYDROGEN", 6}, {"OXYGEN", 1}}},
        -:   37:    {"GLUCOSE", {{"CARBON", 6}, {"HYDROGEN", 12}, {"OXYGEN", 6}}}
        -:   38:};
        -:   39:
        -:   40:// Drink recipes: drinks consist of multiple molecules
        -:   41:map<string, vector<string>> drink_recipes = {
        -:   42:    {"SOFT DRINK", {"WATER", "CARBON DIOXIDE", "GLUCOSE"}},
        -:   43:    {"VODKA", {"WATER", "ALCOHOL", "GLUCOSE"}},
        -:   44:    {"CHAMPAGNE", {"WATER", "CARBON DIOXIDE", "ALCOHOL"}}
        -:   45:};
        -:   46:
        -:   47:// Inventory of created molecules
        -:   48:map<string, unsigned long long> molecule_inventory;
        -:   49:
        -:   50:/**
        -:   51: * @brief Prints the current inventory of atoms.
        -:   52: */
function _Z15print_inventoryv called 13 returned 100% blocks executed 61%
       13:   53:void print_inventory() {
       26:   54:    cout << "CARBON: " << atom_inventory["CARBON"]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 never executed
       39:   55:         << ", OXYGEN: " << atom_inventory["OXYGEN"]
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 never executed
       39:   56:         << ", HYDROGEN: " << atom_inventory["HYDROGEN"] << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 never executed
       13:   57:}
        -:   58:
        -:   59:/**
        -:   60: * @brief Adds a given amount of atoms to the inventory if valid.
        -:   61: * @param atom_type The type of atom to add (CARBON, OXYGEN, HYDROGEN).
        -:   62: * @param amount_string The amount as a string (validated and converted).
        -:   63: */
function _Z9add_atomsRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 13 returned 100% blocks executed 96%
       13:   64:void add_atoms(const string& atom_type, const string& amount_string) {
       13:   65:    if (!all_of(amount_string.begin(), amount_string.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 23% (fallthrough)
branch  4 taken 77%
        3:   66:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 returned 100%
call    1 returned 100%
        3:   67:        return;
        -:   68:    }
        -:   69:    try {
       10:   70:        unsigned long long amount = stoull(amount_string);
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30% (throw)
        7:   71:        if (atom_inventory[atom_type] + amount > MAX_VALUE) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
        1:   72:            cerr << "Invalid command: not enough place for the atoms!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:   73:            return;
        -:   74:        }
        6:   75:        atom_inventory[atom_type] += amount;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:   76:    } catch (...) {
call    0 returned 100%
        3:   77:        cerr << "Error converting number" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        3:   78:    }
call    0 returned 100%
call    1 never executed
        -:   79:}
        -:   80:
        -:   81:/**
        -:   82: * @brief Handles a TCP command from the client (currently supports ADD).
        -:   83: * @param command The full command line string received.
        -:   84: */
function _Z18handle_tcp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 21 returned 100% blocks executed 82%
       21:   85:void handle_tcp_command(const string& command) {
       21:   86:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       21:   87:    string action, atom_type, amount_string;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       21:   88:    iss >> action >> atom_type >> amount_string;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
       21:   89:    transform(atom_type.begin(), atom_type.end(), atom_type.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       21:   90:    if (action != "ADD" || atom_inventory.find(atom_type) == atom_inventory.end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 86% (fallthrough)
branch  4 taken 14%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 22% (fallthrough)
branch 11 taken 78%
branch 12 taken 33% (fallthrough)
branch 13 taken 67%
        7:   91:        cerr << "Invalid command!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        7:   92:        return;
        -:   93:    }
        -:   94:    // detect extra arguments
       14:   95:    string extra; 
call    0 returned 100%
       14:   96:    if (iss >> extra) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 7% (fallthrough)
branch  7 taken 93%
        1:   97:        cerr << "Invalid command: too many arguments!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:   98:        return;
        -:   99:    }
       13:  100:    add_atoms(atom_type, amount_string);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  101:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       46:  102:}
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
call    3 returned 100%
branch  4 taken 62% (fallthrough)
branch  5 taken 38%
call    6 returned 100%
branch  7 taken 62% (fallthrough)
branch  8 taken 38%
call    9 returned 100%
branch 10 taken 62% (fallthrough)
branch 11 taken 38%
call   12 returned 100%
branch 13 taken 62% (fallthrough)
branch 14 taken 38%
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  103:
        -:  104:
        -:  105:/**
        -:  106: * @brief Handles a UDP DELIVER command and updates inventories accordingly.
        -:  107: * @param command The full UDP command string.
        -:  108: * @return A status string indicating success or the specific error.
        -:  109: */
function _Z18handle_udp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:  110:string handle_udp_command(const string& command) {
    #####:  111:    istringstream iss(command);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  112:    string action;
call    0 never executed
    #####:  113:    iss >> action;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  114:    if (action != "DELIVER") return "ERROR: Invalid command";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
branch  3 never executed (fallthrough)
branch  4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
        -:  115:
    #####:  116:    vector<string> tokens;
call    0 never executed
    #####:  117:    string token;
call    0 never executed
    #####:  118:    while (iss >> token) tokens.push_back(token);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
branch  9 never executed
branch 10 never executed (fallthrough)
    #####:  119:    if (tokens.size() < 2) return "ERROR: Invalid command format";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
        -:  120:
    #####:  121:    string count_str = tokens.back();
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  122:    if (!all_of(count_str.begin(), count_str.end(), ::isdigit)) return "ERROR: Not a positive number";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
branch  5 never executed (fallthrough)
branch  6 never executed
call    7 never executed
branch  8 never executed (fallthrough)
branch  9 never executed (throw)
        -:  123:
    #####:  124:    unsigned long long count = stoull(count_str);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  125:    string molecule_name;
call    0 never executed
    #####:  126:    for (size_t i = 0; i < tokens.size() - 1; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:  127:        if (!molecule_name.empty()) molecule_name += " ";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  128:        molecule_name += tokens[i];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:  129:    }
        -:  130:
    #####:  131:    string atom_name = "";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  132:    string real_molecule = molecule_name;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  133:    if (tokens.size() > 3) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  134:        atom_name = tokens[0];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  135:        real_molecule = molecule_name.substr(atom_name.size() + 1); // Remove atom prefix if exists
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
call    5 never executed
        -:  136:    }
        -:  137:
    #####:  138:    if (molecule_recipes.find(real_molecule) == molecule_recipes.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  139:        return "ERROR: Unknown molecule '" + real_molecule + "'";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
        -:  140:    }
        -:  141:
    #####:  142:    const auto& recipe = molecule_recipes[real_molecule];
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  143:    map<string, unsigned long long> needed;
call    0 never executed
    #####:  144:    for (const auto& [atom, per_mol] : recipe) needed[atom] += per_mol * count;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed (fallthrough)
        -:  145:
    #####:  146:    if (!atom_name.empty()) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  147:        string upper_atom = atom_name;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  148:        transform(upper_atom.begin(), upper_atom.end(), upper_atom.begin(), ::toupper);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  149:        if (atom_inventory.find(upper_atom) == atom_inventory.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  150:            return "ERROR: Invalid atom '" + upper_atom + "'";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
        -:  151:        }
    #####:  152:        needed[upper_atom] += count;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  153:    }
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
call    3 never executed
        -:  154:
        -:  155:    // Check if any atoms are missing for the delivery
    #####:  156:    vector<string> missing_atoms;
call    0 never executed
    #####:  157:    for (const auto& [atom, need_count] : needed) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed (fallthrough)
    #####:  158:        if (atom_inventory[atom] < need_count) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:  159:            unsigned long long missing = need_count - atom_inventory[atom];
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  160:            missing_atoms.push_back(to_string(missing) + " " + atom);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
        -:  161:        }
        -:  162:    }
        -:  163:
    #####:  164:    if (!missing_atoms.empty()) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:  165:        string error = "ERROR: Not enough atoms â€“ missing ";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  166:        for (size_t i = 0; i < missing_atoms.size(); ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:  167:            if (i > 0) error += ", ";
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  168:            error += missing_atoms[i];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:  169:        }
    #####:  170:        return error;
call    0 never executed
    #####:  171:    }
call    0 never executed
call    1 never executed
        -:  172:
    #####:  173:    for (const auto& [atom, need_count] : needed)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed (fallthrough)
    #####:  174:        atom_inventory[atom] -= need_count;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
        -:  175:
    #####:  176:    molecule_inventory[real_molecule] += count;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  177:    print_inventory();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  178:    return "OK: Delivered " + to_string(count) + " " + molecule_name + " molecules";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
branch 13 never executed (fallthrough)
branch 14 never executed (throw)
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
    #####:  179:}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  180:/**
        -:  181: * @brief Computes how many full drinks of a type can be prepared with available atoms.
        -:  182: * @param drink_name The name of the drink (e.g., "VODKA").
        -:  183: * @return Number of drinks that can be prepared.
        -:  184: */
function _Z19compute_drink_countRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 4 returned 100% blocks executed 63%
        4:  185:unsigned long long compute_drink_count(const string& drink_name) {
        -:  186:    // Required atom counts for one drink
        4:  187:    unsigned long long needed_carbon = 0;
        4:  188:    unsigned long long needed_hydrogen = 0;
        4:  189:    unsigned long long needed_oxygen = 0;
        -:  190:
        4:  191:    if (drink_name == "SOFT DRINK") {
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  192:        // Contains: WATER (H2O), CARBON DIOXIDE (CO2), GLUCOSE (C6H12O6)
        1:  193:        needed_carbon = 1 + 6;           // 1 from CO2, 6 from GLUCOSE
        1:  194:        needed_hydrogen = 2 + 12;        // 2 from WATER, 12 from GLUCOSE
        1:  195:        needed_oxygen = 1 + 2 + 6;       // 1 from WATER, 2 from CO2, 6 from GLUCOSE
        3:  196:    } else if (drink_name == "VODKA") {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
        -:  197:        // Contains: WATER, ALCOHOL (C2H6O), GLUCOSE
        2:  198:        needed_carbon = 2 + 6;           // 2 from ALCOHOL, 6 from GLUCOSE
        2:  199:        needed_hydrogen = 2 + 6 + 12;    // 2 from WATER, 6 from ALCOHOL, 12 from GLUCOSE
        2:  200:        needed_oxygen = 1 + 1 + 6;       // 1 from WATER, 1 from ALCOHOL, 6 from GLUCOSE
        1:  201:    } else if (drink_name == "CHAMPAGNE") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  202:        // Contains: WATER, CO2, ALCOHOL
        1:  203:        needed_carbon = 1 + 2;           // 1 from CO2, 2 from ALCOHOL
        1:  204:        needed_hydrogen = 2 + 6;         // 2 from WATER, 6 from ALCOHOL
        1:  205:        needed_oxygen = 1 + 2 + 1;       // 1 from WATER, 2 from CO2, 1 from ALCOHOL
        -:  206:    } else {
        -:  207:        // Drink not recognized
    #####:  208:        return 0;
        -:  209:    }
        -:  210:
        -:  211:    // Calculate how many full drinks can be made based on current atom inventory
        8:  212:    unsigned long long from_carbon = atom_inventory["CARBON"] / needed_carbon;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        8:  213:    unsigned long long from_hydrogen = atom_inventory["HYDROGEN"] / needed_hydrogen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        4:  214:    unsigned long long from_oxygen = atom_inventory["OXYGEN"] / needed_oxygen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        -:  215:
        -:  216:    // The limiting atom determines the maximum number of drinks possible
        4:  217:    return std::min({from_carbon, from_hydrogen, from_oxygen});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  218:}
        -:  219:
        -:  220:/**
        -:  221: * @brief Main server loop. Listens on TCP and UDP ports and handles incoming commands.
        -:  222: */
function main called 3 returned 67% blocks executed 64%
        3:  223:int main(int argc, char* argv[]) {
        3:  224:    signal(SIGINT, handle_sigint);  // Catch Ctrl+C
call    0 returned 100%
        3:  225:    if (argc != 3) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        2:  226:        cerr << "Usage: " << argv[0] << " <TCP_PORT> <UDP_PORT>" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        2:  227:        return 1;
        -:  228:    }
        1:  229:    int tcp_port = atoi(argv[1]);
        1:  230:    int udp_port = atoi(argv[2]);
        -:  231:
        -:  232:    // Create and bind TCP socket
        1:  233:    int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
call    0 returned 100%
        1:  234:    sockaddr_in tcp_addr {};
        1:  235:    tcp_addr.sin_family = AF_INET;
        1:  236:    tcp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  237:    tcp_addr.sin_port = htons(tcp_port);
        1:  238:    bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr));
call    0 returned 100%
        1:  239:    listen(tcp_sock, 5);
call    0 returned 100%
        -:  240:
        -:  241:    // Create and bind UDP socket
        1:  242:    int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
call    0 returned 100%
        1:  243:    sockaddr_in udp_addr {};
        1:  244:    udp_addr.sin_family = AF_INET;
        1:  245:    udp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  246:    udp_addr.sin_port = htons(udp_port);
        1:  247:    bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr));
call    0 returned 100%
        -:  248:
        1:  249:    cout << "bar_drinks running on TCP port " << tcp_port << " and UDP port " << udp_port << "..." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
        -:  250:
        1:  251:    tcflush(STDIN_FILENO, TCIFLUSH); // Clear input buffer before select
call    0 returned 100%
        -:  252:    fd_set master, read_fds;
       17:  253:    FD_ZERO(&master);
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        1:  254:    FD_SET(tcp_sock, &master);
        1:  255:    FD_SET(udp_sock, &master);
        1:  256:    FD_SET(STDIN_FILENO, &master);
        1:  257:    int fdmax = max({tcp_sock, udp_sock, STDIN_FILENO});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  258:
        1:  259:    vector<int> clients;
call    0 returned 100%
        -:  260:
        -:  261:    while (true) {
       35:  262:        read_fds = master;
       35:  263:        FD_SET(STDIN_FILENO, &read_fds);
       35:  264:        if (select(fdmax + 1, &read_fds, nullptr, nullptr, nullptr) < 0) {
call    0 returned 97%
branch  1 taken 97% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  265:            perror("select");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  266:            break;
        -:  267:        }
        -:  268:
      238:  269:        for (int i = 0; i <= fdmax; ++i) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
      204:  270:            if (!FD_ISSET(i, &read_fds)) continue;
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  271:
       34:  272:            if (i == tcp_sock) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  273:                // Handle new TCP connection
        1:  274:                int newfd = accept(tcp_sock, nullptr, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       1*:  275:                if (newfd < 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  276:                    perror("accept failed");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  277:                    continue;
        -:  278:                }
        1:  279:                FD_SET(newfd, &master);
        1:  280:                fdmax = max({fdmax, newfd}); 
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  281:                clients.push_back(newfd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  282:
       33:  283:            } else if (i == udp_sock) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  284:                // Handle UDP request
    #####:  285:                char buf[1024] = {0};
    #####:  286:                sockaddr_in client_addr {};
    #####:  287:                socklen_t len = sizeof(client_addr);
    #####:  288:                int n = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  289:                if (n > 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  290:                    string response = handle_udp_command(string(buf));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
    #####:  291:                    cout << response << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  292:                    sendto(udp_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  293:                }
call    0 never executed
call    1 never executed
        -:  294:
       33:  295:            } else if (i == STDIN_FILENO) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  296:                // Handle local user input from keyboard
       11:  297:                string line;
call    0 returned 100%
       11:  298:                getline(cin, line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       11:  299:                transform(line.begin(), line.end(), line.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       11:  300:                istringstream iss(line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       11:  301:                string command, drink;
call    0 returned 100%
call    1 returned 100%
       11:  302:                iss >> command;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       11:  303:                getline(iss, drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       11:  304:                drink.erase(0, drink.find_first_not_of(" "));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       11:  305:                transform(drink.begin(), drink.end(), drink.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  306:
       11:  307:                if (command == "GEN" && drink_recipes.find(drink) != drink_recipes.end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 82% (fallthrough)
branch  4 taken 18%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 44% (fallthrough)
branch 11 taken 56%
branch 12 taken 36% (fallthrough)
branch 13 taken 64%
        4:  308:                   unsigned long long count = compute_drink_count(drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        4:  309:                    cout << "Can prepare " << count << " " << drink << " drinks" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
        -:  310:                } else {
        7:  311:                    cout << "Unknown drink command: " << line << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  312:                }
        -:  313:
       11:  314:            } else {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  315:                // Handle incoming TCP message from existing client
       22:  316:                char buf[1024] = {0};
       22:  317:                int n = recv(i, buf, sizeof(buf) - 1, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       22:  318:                if (n <= 0) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        1:  319:                    close(i);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  320:                    FD_CLR(i, &master);
        -:  321:                } else {
       42:  322:                    handle_tcp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  323:                }
        -:  324:            }
        -:  325:        }
       34:  326:    }
    #####:  327:    return 0;
    #####:  328:}
call    0 never executed
call    1 never executed
