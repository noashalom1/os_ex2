        -:    0:Source:drinks_bar.cpp
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:6
        -:    1:#include <iostream>
        -:    2:#include <string>
        -:    3:#include <map>
        -:    4:#include <vector>
        -:    5:#include <sstream>
        -:    6:#include <algorithm>
        -:    7:#include <unistd.h>
        -:    8:#include <cstring>
        -:    9:#include <netinet/in.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/select.h>
        -:   12:#include <climits>
        -:   13:#include <cstdlib>
        -:   14:#include <csignal>  // for the signals 
        -:   15:#include <cstdlib>  // exit()
        -:   16:
        -:   17:#define MAX_VALUE 1000000000000000000
        -:   18:
        -:   19:using namespace std;
        -:   20:
        -:   21:/**
        -:   22: * @brief Handles SIGINT (Ctrl+C) signal and exits cleanly.
        -:   23: */
function _Z13handle_siginti called 1 returned 0% blocks executed 100%
        1:   24:void handle_sigint([[maybe_unused]] int sig) {
        1:   25:    cout << "\nðŸ“¤ Caught SIGINT (Ctrl+C). Exiting cleanly...\n";
call    0 returned 100%
        1:   26:    exit(0);  // makes the .gcda 
        -:   27:}
        -:   28:
        -:   29:// Global inventory for atoms (Carbon, Oxygen, Hydrogen)
        -:   30:map<string, unsigned long long> atom_inventory = {
        -:   31:    {"CARBON", 0}, {"OXYGEN", 0}, {"HYDROGEN", 0}
        -:   32:};
        -:   33:
        -:   34:// Molecule recipes: how many atoms of each type needed per molecule
        -:   35:map<string, map<string, int>> molecule_recipes = {
        -:   36:    {"WATER", {{"HYDROGEN", 2}, {"OXYGEN", 1}}},
        -:   37:    {"CARBON DIOXIDE", {{"CARBON", 1}, {"OXYGEN", 2}}},
        -:   38:    {"ALCOHOL", {{"CARBON", 2}, {"HYDROGEN", 6}, {"OXYGEN", 1}}},
        -:   39:    {"GLUCOSE", {{"CARBON", 6}, {"HYDROGEN", 12}, {"OXYGEN", 6}}}
        -:   40:};
        -:   41:
        -:   42:// Drink recipes: drinks consist of multiple molecules
        -:   43:map<string, vector<string>> drink_recipes = {
        -:   44:    {"SOFT DRINK", {"WATER", "CARBON DIOXIDE", "GLUCOSE"}},
        -:   45:    {"VODKA", {"WATER", "ALCOHOL", "GLUCOSE"}},
        -:   46:    {"CHAMPAGNE", {"WATER", "CARBON DIOXIDE", "ALCOHOL"}}
        -:   47:};
        -:   48:
        -:   49:map<string, unsigned long long> molecule_inventory; // Inventory of created molecules
        -:   50:
        -:   51:/**
        -:   52: * @brief Prints the current atom inventory.
        -:   53: */
function _Z15print_inventoryv called 22 returned 100% blocks executed 61%
       22:   54:void print_inventory() {
       44:   55:    cout << "CARBON: " << atom_inventory["CARBON"]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 never executed
       66:   56:         << ", OXYGEN: " << atom_inventory["OXYGEN"]
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 never executed
       66:   57:         << ", HYDROGEN: " << atom_inventory["HYDROGEN"] << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 never executed
       22:   58:}
        -:   59:
        -:   60:/**
        -:   61: * @brief Adds a specified count of molecules to the molecule inventory.
        -:   62: */
function _Z26add_molecules_to_inventoryRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEy called 0 returned 0% blocks executed 0%
    #####:   63:void add_molecules_to_inventory(const string& molecule_name, unsigned long long count) {
    #####:   64:    molecule_inventory[molecule_name] += count;
call    0 never executed
    #####:   65:}
        -:   66:
        -:   67:/**
        -:   68: * @brief Adds a given amount of atoms to the inventory if valid.
        -:   69: * @param atom_type The type of atom to add (CARBON, OXYGEN, HYDROGEN).
        -:   70: * @param amount_string The amount as a string (validated and converted).
        -:   71: */
function _Z9add_atomsRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 16 returned 100% blocks executed 96%
       16:   72:void add_atoms(const string& atom_type, const string& amount_string) {
       16:   73:    if (!all_of(amount_string.begin(), amount_string.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 19% (fallthrough)
branch  4 taken 81%
        3:   74:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 returned 100%
call    1 returned 100%
        3:   75:        return;
        -:   76:    }
        -:   77:    try {
       13:   78:        unsigned long long amount = stoull(amount_string);
call    0 returned 100%
branch  1 taken 77% (fallthrough)
branch  2 taken 23% (throw)
       10:   79:        if (atom_inventory[atom_type] + amount > MAX_VALUE) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 10% (fallthrough)
branch  4 taken 90%
        1:   80:            cerr << "Invalid command: not enough place for the atoms!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:   81:            return;
        -:   82:        }
        9:   83:        atom_inventory[atom_type] += amount;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:   84:    } catch (...) {
call    0 returned 100%
        3:   85:        cerr << "Error converting number" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        3:   86:    }
call    0 returned 100%
call    1 never executed
        -:   87:}
        -:   88:
        -:   89:/**
        -:   90: * @brief Parses and validates a timeout value from string to integer.
        -:   91: */
function _Z11set_timeoutRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 0 returned 0% blocks executed 0%
    #####:   92:int set_timeout(const string& timeout) {
    #####:   93:    if (!all_of(timeout.begin(), timeout.end(), ::isdigit)) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed
    #####:   94:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 never executed
call    1 never executed
    #####:   95:        return 0;
        -:   96:    }
        -:   97:
        -:   98:    try {
    #####:   99:        int time = stoull(timeout); 
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  100:        return time;
    =====:  101:    } catch (const exception& e) {
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    =====:  102:        cerr << "Error converting number" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    =====:  103:        return 0;
    =====:  104:    }
call    0 never executed
call    1 never executed
        -:  105:}
        -:  106:
        -:  107:/**
        -:  108: * @brief Handles a TCP command from the client (currently supports ADD).
        -:  109: * @param command The full command line string received.
        -:  110: */
function _Z18handle_tcp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 22 returned 100% blocks executed 82%
       22:  111:void handle_tcp_command(const string& command) {
       22:  112:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       22:  113:    string action, atom_type, amount_string;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       22:  114:    iss >> action >> atom_type >> amount_string;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
       22:  115:    transform(atom_type.begin(), atom_type.end(), atom_type.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       22:  116:    if (action != "ADD" || atom_inventory.find(atom_type) == atom_inventory.end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 82% (fallthrough)
branch  4 taken 18%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 22% (fallthrough)
branch 11 taken 78%
branch 12 taken 36% (fallthrough)
branch 13 taken 64%
        8:  117:        cerr << "Invalid command!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        8:  118:        return;
        -:  119:    }
        -:  120:    // detect extra arguments
       14:  121:    string extra; 
call    0 returned 100%
       14:  122:    if (iss >> extra) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 7% (fallthrough)
branch  7 taken 93%
        1:  123:        cerr << "Invalid command: too many arguments!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  124:        return;
        -:  125:    }
       13:  126:    add_atoms(atom_type, amount_string);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  127:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       50:  128:}
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
call    3 returned 100%
branch  4 taken 59% (fallthrough)
branch  5 taken 41%
call    6 returned 100%
branch  7 taken 59% (fallthrough)
branch  8 taken 41%
call    9 returned 100%
branch 10 taken 59% (fallthrough)
branch 11 taken 41%
call   12 returned 100%
branch 13 taken 59% (fallthrough)
branch 14 taken 41%
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  129:
        -:  130:
        -:  131:/**
        -:  132: * @brief Handles a UDP DELIVER command and updates inventories accordingly.
        -:  133: * @param command The full UDP command string.
        -:  134: * @return A status string indicating success or the specific error.
        -:  135: */
function _Z18handle_udp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 19 returned 100% blocks executed 49%
       19:  136:string handle_udp_command(const string& command) {
       19:  137:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  138:    string action;
call    0 returned 100%
       19:  139:    iss >> action;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       21:  140:    if (action != "DELIVER") return "ERROR: Invalid command";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 5% (fallthrough)
branch  4 taken 95%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
        -:  141:
       18:  142:    vector<string> tokens;
call    0 returned 100%
       18:  143:    string token;
call    0 returned 100%
       55:  144:    while (iss >> token) tokens.push_back(token);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 67%
branch 10 taken 33% (fallthrough)
       22:  145:    if (tokens.size() < 2) return "ERROR: Invalid command format";
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  146:
       16:  147:    string count_str = tokens.back();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       20:  148:    if (!all_of(count_str.begin(), count_str.end(), ::isdigit)) return "ERROR: Not a positive number";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 12% (fallthrough)
branch  6 taken 88%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
        -:  149:
        -:  150:    unsigned long long count;
        -:  151:    try {
       14:  152:    count = stoull(count_str);
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7% (throw)
        1:  153:    } catch (const std::exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        1:  154:        return "ERROR: Invalid count - not a valid number";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  155:    }
call    0 returned 100%
call    1 never executed
        -:  156:
       13:  157:    string molecule_name;
call    0 returned 100%
       30:  158:    for (size_t i = 0; i < tokens.size() - 1; ++i) {
call    0 returned 100%
branch  1 taken 57%
branch  2 taken 43% (fallthrough)
       17:  159:        if (!molecule_name.empty()) molecule_name += " ";
call    0 returned 100%
branch  1 taken 24% (fallthrough)
branch  2 taken 76%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
       17:  160:        molecule_name += tokens[i];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  161:    }
        -:  162:
       13:  163:    string atom_name = "";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  164:    string real_molecule = molecule_name;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  165:    if (tokens.size() > 3) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  166:        atom_name = tokens[0];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  167:        real_molecule = molecule_name.substr(atom_name.size() + 1); // Remove atom prefix if exists
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
call    5 never executed
        -:  168:    }
        -:  169:
       13:  170:    if (molecule_recipes.find(real_molecule) == molecule_recipes.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 38% (fallthrough)
branch  6 taken 62%
        5:  171:        return "ERROR: Unknown molecule '" + real_molecule + "'";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  172:    }
        -:  173:
        8:  174:    const auto& recipe = molecule_recipes[real_molecule];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  175:    map<string, unsigned long long> needed;
call    0 returned 100%
       28:  176:    for (const auto& [atom, per_mol] : recipe) needed[atom] += per_mol * count;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
call    9 returned 100%
branch 10 taken 71%
branch 11 taken 29% (fallthrough)
        -:  177:
        8:  178:    if (!atom_name.empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  179:        string upper_atom = atom_name;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  180:        transform(upper_atom.begin(), upper_atom.end(), upper_atom.begin(), ::toupper);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  181:        if (atom_inventory.find(upper_atom) == atom_inventory.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  182:            return "ERROR: Invalid atom '" + upper_atom + "'";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
        -:  183:        }
    #####:  184:        needed[upper_atom] += count;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  185:    }
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
call    3 never executed
        -:  186:
        -:  187:    // Check if any atoms are missing for the delivery
        8:  188:    vector<string> missing_atoms;
call    0 returned 100%
       28:  189:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 71%
branch  8 taken 29% (fallthrough)
       20:  190:        if (atom_inventory[atom] < need_count) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  191:            unsigned long long missing = need_count - atom_inventory[atom];
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  192:            missing_atoms.push_back(to_string(missing) + " " + atom);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
        -:  193:        }
        -:  194:    }
        -:  195:
        8:  196:    if (!missing_atoms.empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  197:        string error = "ERROR: Not enough atoms â€“ missing ";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  198:        for (size_t i = 0; i < missing_atoms.size(); ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:  199:            if (i > 0) error += ", ";
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  200:            error += missing_atoms[i];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:  201:        }
    #####:  202:        return error;
call    0 never executed
    #####:  203:    }
call    0 never executed
call    1 never executed
        -:  204:
       28:  205:    for (const auto& [atom, need_count] : needed)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       20:  206:        atom_inventory[atom] -= need_count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  207:
        8:  208:    molecule_inventory[real_molecule] += count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  209:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  210:    return "OK: Delivered " + to_string(count) + " " + molecule_name + " molecules";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
       19:  211:}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  212:
        -:  213:/**
        -:  214: * @brief Computes how many full drinks of a type can be prepared with available atoms.
        -:  215: * @param drink_name The name of the drink (e.g., "VODKA").
        -:  216: * @return Number of drinks that can be prepared.
        -:  217: */
function _Z19compute_drink_countRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 63%
        3:  218:unsigned long long compute_drink_count(const string& drink_name) {
        -:  219:    // Required atom counts for one drink
        3:  220:    unsigned long long needed_carbon = 0;
        3:  221:    unsigned long long needed_hydrogen = 0;
        3:  222:    unsigned long long needed_oxygen = 0;
        -:  223:
        3:  224:    if (drink_name == "SOFT DRINK") {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  225:        // Contains: WATER (H2O), CARBON DIOXIDE (CO2), GLUCOSE (C6H12O6)
        1:  226:        needed_carbon = 1 + 6;           // 1 from CO2, 6 from GLUCOSE
        1:  227:        needed_hydrogen = 2 + 12;        // 2 from WATER, 12 from GLUCOSE
        1:  228:        needed_oxygen = 1 + 2 + 6;       // 1 from WATER, 2 from CO2, 6 from GLUCOSE
        2:  229:    } else if (drink_name == "VODKA") {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  230:        // Contains: WATER, ALCOHOL (C2H6O), GLUCOSE
        1:  231:        needed_carbon = 2 + 6;           // 2 from ALCOHOL, 6 from GLUCOSE
        1:  232:        needed_hydrogen = 2 + 6 + 12;    // 2 from WATER, 6 from ALCOHOL, 12 from GLUCOSE
        1:  233:        needed_oxygen = 1 + 1 + 6;       // 1 from WATER, 1 from ALCOHOL, 6 from GLUCOSE
        1:  234:    } else if (drink_name == "CHAMPAGNE") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  235:        // Contains: WATER, CO2, ALCOHOL
        1:  236:        needed_carbon = 1 + 2;           // 1 from CO2, 2 from ALCOHOL
        1:  237:        needed_hydrogen = 2 + 6;         // 2 from WATER, 6 from ALCOHOL
        1:  238:        needed_oxygen = 1 + 2 + 1;       // 1 from WATER, 2 from CO2, 1 from ALCOHOL
        -:  239:    } else {
        -:  240:        // Drink not recognized
    #####:  241:        return 0;
        -:  242:    }
        -:  243:
        -:  244:    // Calculate how many full drinks can be made based on current atom inventory
        6:  245:    unsigned long long from_carbon = atom_inventory["CARBON"] / needed_carbon;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        6:  246:    unsigned long long from_hydrogen = atom_inventory["HYDROGEN"] / needed_hydrogen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        3:  247:    unsigned long long from_oxygen = atom_inventory["OXYGEN"] / needed_oxygen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        -:  248:
        -:  249:    // The limiting atom determines the maximum number of drinks possible
        3:  250:    return std::min({from_carbon, from_hydrogen, from_oxygen});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  251:}
        -:  252:
        -:  253:/**
        -:  254: * @brief Main server function: initializes sockets, parses flags, and runs event loop.
        -:  255: */
function main called 6 returned 83% blocks executed 65%
        6:  256:int main(int argc, char* argv[]) {
        6:  257:    signal(SIGINT, handle_sigint);  // Catch Ctrl+C
call    0 returned 100%
        6:  258:    int tcp_port = -1, udp_port = -1;
        6:  259:    int timeout = -1;
        -:  260:    int opt;
       16:  261:    while ((opt = getopt(argc, argv, "T:U:o:c:h:t:")) != -1) {
call    0 returned 100%
branch  1 taken 75%
branch  2 taken 25% (fallthrough)
       12:  262:        switch (opt) {
branch  0 taken 33%
branch  1 taken 25%
branch  2 taken 8%
branch  3 taken 8%
branch  4 taken 8%
branch  5 taken 0%
branch  6 taken 17%
        4:  263:            case 'T': tcp_port = atoi(optarg); break;
        3:  264:            case 'U': udp_port = atoi(optarg); break;
        5:  265:            case 'o': add_atoms("OXYGEN", string(optarg)); break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        5:  266:            case 'c': add_atoms("CARBON", string(optarg)); break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
        5:  267:            case 'h': add_atoms("HYDROGEN", string(optarg)); break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
call   10 returned 100%
call   11 never executed
call   12 never executed
    #####:  268:            case 't': timeout = set_timeout(string(optarg)); break;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
        2:  269:            default:
        2:  270:                cerr << "Usage: ./drinks_bar -T <tcp_port> -U <udp_port> [-o num] [-c num] [-h num] [-t timeout]" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:  271:                return 1;
        -:  272:        }
        -:  273:    }
        -:  274:
        4:  275:    if (tcp_port == -1 || udp_port == -1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        3:  276:        cerr << "ERROR: TCP and UDP ports are required (use -T and -U)" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        3:  277:        return 1;
        -:  278:    }
        -:  279:
        1:  280:    int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
call    0 returned 100%
        1:  281:    sockaddr_in tcp_addr{};
        1:  282:    tcp_addr.sin_family = AF_INET;
        1:  283:    tcp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  284:    tcp_addr.sin_port = htons(tcp_port);
        1:  285:    bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr));
call    0 returned 100%
        1:  286:    listen(tcp_sock, 5);
call    0 returned 100%
        -:  287:
        1:  288:    int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
call    0 returned 100%
        1:  289:    sockaddr_in udp_addr{};
        1:  290:    udp_addr.sin_family = AF_INET;
        1:  291:    udp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  292:    udp_addr.sin_port = htons(udp_port);
        1:  293:    bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr));
call    0 returned 100%
        -:  294:
        1:  295:    cout << "bar_drinks running on TCP port " << tcp_port
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  296:         << " and UDP port " << udp_port << "..." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        -:  297:    
        1:  298:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  299:
        -:  300:    fd_set master, read_fds;
       17:  301:    FD_ZERO(&master);
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        1:  302:    FD_SET(tcp_sock, &master);
        1:  303:    FD_SET(udp_sock, &master);
        1:  304:    FD_SET(STDIN_FILENO, &master);
        1:  305:    int fdmax = max({tcp_sock, udp_sock, STDIN_FILENO});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  306:
        1:  307:    timeval* timeout_ptr = nullptr;
        1:  308:    timeval timeout_val{};
        1:  309:    if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  310:        timeout_val.tv_sec = timeout;
    #####:  311:        timeout_val.tv_usec = 0;
    #####:  312:        timeout_ptr = &timeout_val;
        -:  313:    }
        -:  314:
       1*:  315:    vector<int> clients;
call    0 returned 100%
call    1 never executed
        -:  316:
        -:  317:    while (true) {
       60:  318:        read_fds = master;
       60:  319:        int activity = select(fdmax + 1, &read_fds, nullptr, nullptr, timeout_ptr);
call    0 returned 98%
branch  1 taken 98% (fallthrough)
branch  2 taken 0% (throw)
       59:  320:        if (activity < 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  321:            perror("select");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  322:            break;
       59:  323:        } else if (activity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  324:            cout << "Timeout reached with no activity. Server exiting." << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    #####:  325:            break;
        -:  326:        }
        -:  327:
      413:  328:        for (int i = 0; i <= fdmax; ++i) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
      354:  329:            if (!FD_ISSET(i, &read_fds)) continue;
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  330:
       59:  331:            if (i == tcp_sock) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        2:  332:                int newfd = accept(tcp_sock, nullptr, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  333:                FD_SET(newfd, &master);
        2:  334:                if (newfd > fdmax) fdmax = newfd;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  335:                clients.push_back(newfd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  336:                if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  337:                timeout_val.tv_sec = timeout;
    #####:  338:                timeout_val.tv_usec = 0;
    #####:  339:                timeout_ptr = &timeout_val;
        -:  340:                }
       57:  341:            } else if (i == udp_sock) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
       19:  342:                char buf[1024] = {0};
       19:  343:                sockaddr_in client_addr{};
       19:  344:                socklen_t len = sizeof(client_addr);
       19:  345:                int n = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  346:                if (n > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       19:  347:                    string response = handle_udp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       19:  348:                    if (response.rfind("ERROR", 0) == 0) cerr << response << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 58% (fallthrough)
branch  4 taken 42%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
       19:  349:                    sendto(udp_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       19:  350:                    if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  351:                    timeout_val.tv_sec = timeout;
    #####:  352:                    timeout_val.tv_usec = 0;
    #####:  353:                    timeout_ptr = &timeout_val;
        -:  354:                    }
       19:  355:                }
call    0 returned 100%
call    1 never executed
       38:  356:            } else if (i == STDIN_FILENO) {
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
       14:  357:                string line;
call    0 returned 100%
       14:  358:                getline(cin, line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  359:                transform(line.begin(), line.end(), line.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       14:  360:                istringstream iss(line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  361:                string command, drink;
call    0 returned 100%
call    1 returned 100%
       14:  362:                iss >> command;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  363:                getline(iss, drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       14:  364:                drink.erase(0, drink.find_first_not_of(" "));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       14:  365:                transform(command.begin(), command.end(), command.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       14:  366:                transform(drink.begin(), drink.end(), drink.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       14:  367:                if (command == "GEN" && drink_recipes.find(drink) != drink_recipes.end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 64% (fallthrough)
branch  4 taken 36%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 33% (fallthrough)
branch 11 taken 67%
branch 12 taken 21% (fallthrough)
branch 13 taken 79%
        3:  368:                    unsigned long long count = compute_drink_count(drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  369:                    cout << "Can prepare " << count << " " << drink << " drinks" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
        -:  370:                } else {
       11:  371:                    cout << "Unknown drink command: " << line << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  372:                }
       14:  373:                if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  374:                timeout_val.tv_sec = timeout;
    #####:  375:                timeout_val.tv_usec = 0;
    #####:  376:                timeout_ptr = &timeout_val;
        -:  377:                }
       14:  378:            } else {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
       24:  379:                char buf[1024] = {0};
       24:  380:                int n = recv(i, buf, sizeof(buf) - 1, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       24:  381:                if (n <= 0) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        2:  382:                    close(i);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  383:                    FD_CLR(i, &master);
        -:  384:                } else {
       22:  385:                    handle_tcp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       22:  386:                    if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  387:                    timeout_val.tv_sec = timeout;
    #####:  388:                    timeout_val.tv_usec = 0;
    #####:  389:                    timeout_ptr = &timeout_val;
        -:  390:                    }
        -:  391:                }
        -:  392:            }
        -:  393:        }
       59:  394:    }
        -:  395:
    #####:  396:    return 0;
call    0 never executed
        -:  397:}
