        -:    0:Source:drinks_bar.cpp
        -:    0:Graph:drinks_bar.gcno
        -:    0:Data:drinks_bar.gcda
        -:    0:Runs:17
        -:    1:#include <iostream>
        -:    2:#include <string>
        -:    3:#include <map>
        -:    4:#include <vector>
        -:    5:#include <sstream>
        -:    6:#include <algorithm>
        -:    7:#include <unistd.h>
        -:    8:#include <cstring>
        -:    9:#include <netinet/in.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/select.h>
        -:   12:#include <climits>
        -:   13:#include <cstdlib>
        -:   14:#include <sys/un.h>
        -:   15:#include <csignal>  // for the signals 
        -:   16:#include <cstdlib>  // exit()
        -:   17:
        -:   18:#define MAX_VALUE 1000000000000000000
        -:   19:#define UNIX_STREAM_PATH "/tmp/drinks_bar_stream.sock"
        -:   20:#define UNIX_DGRAM_PATH "/tmp/drinks_bar_dgram.sock"
        -:   21:
        -:   22:using namespace std;
        -:   23:
        -:   24:/**
        -:   25: * @brief Handles SIGINT (Ctrl+C) signal and exits cleanly.
        -:   26: */
function _Z13handle_siginti called 1 returned 0% blocks executed 100%
        1:   27:void handle_sigint([[maybe_unused]] int sig) {
        1:   28:    cout << "\nðŸ“¤ Caught SIGINT (Ctrl+C). Exiting cleanly...\n";
call    0 returned 100%
        1:   29:    exit(0);  // makes the .gcda 
        -:   30:}
        -:   31:
        -:   32:// Global inventory for atoms (Carbon, Oxygen, Hydrogen)
        -:   33:map<string, unsigned long long> atom_inventory = {
        -:   34:    {"CARBON", 0}, {"OXYGEN", 0}, {"HYDROGEN", 0}
        -:   35:};
        -:   36:
        -:   37:// Molecule recipes: how many atoms of each type needed per molecule
        -:   38:map<string, map<string, int>> molecule_recipes = {
        -:   39:    {"WATER", {{"HYDROGEN", 2}, {"OXYGEN", 1}}},
        -:   40:    {"CARBON DIOXIDE", {{"CARBON", 1}, {"OXYGEN", 2}}},
        -:   41:    {"ALCOHOL", {{"CARBON", 2}, {"HYDROGEN", 6}, {"OXYGEN", 1}}},
        -:   42:    {"GLUCOSE", {{"CARBON", 6}, {"HYDROGEN", 12}, {"OXYGEN", 6}}}
        -:   43:};
        -:   44:
        -:   45:// Drink recipes: drinks consist of multiple molecules
        -:   46:map<string, vector<string>> drink_recipes = {
        -:   47:    {"SOFT DRINK", {"WATER", "CARBON DIOXIDE", "GLUCOSE"}},
        -:   48:    {"VODKA", {"WATER", "ALCOHOL", "GLUCOSE"}},
        -:   49:    {"CHAMPAGNE", {"WATER", "CARBON DIOXIDE", "ALCOHOL"}}
        -:   50:};
        -:   51:
        -:   52:map<string, unsigned long long> molecule_inventory; // Inventory of created molecules
        -:   53:
        -:   54:/**
        -:   55: * @brief Prints the current atom inventory.
        -:   56: */
function _Z15print_inventoryv called 22 returned 100% blocks executed 61%
       22:   57:void print_inventory() {
       44:   58:    cout << "CARBON: " << atom_inventory["CARBON"]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 never executed
       66:   59:         << ", OXYGEN: " << atom_inventory["OXYGEN"]
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 never executed
       66:   60:         << ", HYDROGEN: " << atom_inventory["HYDROGEN"] << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 never executed
       22:   61:}
        -:   62:
        -:   63:/**
        -:   64: * @brief Adds a specified count of molecules to the molecule inventory.
        -:   65: */
function _Z26add_molecules_to_inventoryRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEy called 7 returned 100% blocks executed 100%
        7:   66:void add_molecules_to_inventory(const string& molecule_name, unsigned long long count) {
        7:   67:    molecule_inventory[molecule_name] += count;
call    0 returned 100%
        7:   68:}
        -:   69:
        -:   70:/**
        -:   71: * @brief Adds a given amount of atoms to the inventory if valid.
        -:   72: * @param atom_type The type of atom to add (CARBON, OXYGEN, HYDROGEN).
        -:   73: * @param amount_string The amount as a string (validated and converted).
        -:   74: */
function _Z9add_atomsRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 13 returned 100% blocks executed 92%
       13:   75:void add_atoms(const string& atom_type, const string& amount_string) {
       13:   76:    if (!all_of(amount_string.begin(), amount_string.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 23% (fallthrough)
branch  4 taken 77%
        3:   77:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 returned 100%
call    1 returned 100%
        3:   78:        return;
        -:   79:    }
        -:   80:
        -:   81:    try {
       10:   82:        unsigned long long amount = stoull(amount_string);  
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20% (throw)
        8:   83:        if (atom_inventory[atom_type] + amount > MAX_VALUE) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 25% (fallthrough)
branch  4 taken 75%
        2:   84:            cerr << "Invalid command: not enough place for the atoms!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:   85:            return;
        -:   86:        }
        -:   87:
        6:   88:        atom_inventory[atom_type] += amount;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:   89:    } catch (const exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        2:   90:        cerr << "Error converting number" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:   91:    }
call    0 returned 100%
call    1 never executed
        -:   92:}
        -:   93:
        -:   94:/**
        -:   95: * @brief Converts timeout string to integer seconds.
        -:   96: * @param timeout Timeout as string.
        -:   97: * @return Timeout in seconds.
        -:   98: */
function _Z11set_timeoutRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 44%
        3:   99:int set_timeout(const string& timeout) {
        3:  100:    if (!all_of(timeout.begin(), timeout.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  101:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 never executed
call    1 never executed
    #####:  102:        return 0;
        -:  103:    }
        -:  104:
        -:  105:    try {
        3:  106:        int time = stoull(timeout); 
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  107:        return time;
    =====:  108:    } catch (const exception& e) {
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    =====:  109:        cerr << "Error converting number" << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
    =====:  110:        return 0;
    =====:  111:    }
call    0 never executed
call    1 never executed
        -:  112:}
        -:  113:
        -:  114:/**
        -:  115: * @brief Creates and binds a UNIX stream socket.
        -:  116: * @return File descriptor of the socket.
        -:  117: */
function _Z25create_unix_stream_socketv called 0 returned 0% blocks executed 0%
    #####:  118:int create_unix_stream_socket() {
    #####:  119:    unlink(UNIX_STREAM_PATH); 
call    0 never executed
    #####:  120:    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
call    0 never executed
    #####:  121:    if (sock < 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  122:        perror("UDS STREAM socket");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  123:        exit(1);
call    0 never executed
        -:  124:    }
    #####:  125:    sockaddr_un addr{};
    #####:  126:    addr.sun_family = AF_UNIX;
    #####:  127:    strncpy(addr.sun_path, UNIX_STREAM_PATH, sizeof(addr.sun_path) - 1);
    #####:  128:    bind(sock, (sockaddr*)&addr, sizeof(addr));
call    0 never executed
    #####:  129:    listen(sock, 5);
call    0 never executed
    #####:  130:    return sock;
        -:  131:}
        -:  132:
        -:  133:/**
        -:  134: * @brief Creates and binds a UNIX datagram socket.
        -:  135: * @return File descriptor of the socket.
        -:  136: */
function _Z24create_unix_dgram_socketv called 0 returned 0% blocks executed 0%
    #####:  137:int create_unix_dgram_socket() {
    #####:  138:    unlink(UNIX_DGRAM_PATH);
call    0 never executed
    #####:  139:    int sock = socket(AF_UNIX, SOCK_DGRAM, 0);
call    0 never executed
    #####:  140:    if (sock < 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  141:        perror("UDS DGRAM socket");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  142:        exit(1);
call    0 never executed
        -:  143:    }
    #####:  144:    sockaddr_un addr{};
    #####:  145:    addr.sun_family = AF_UNIX;
    #####:  146:    strncpy(addr.sun_path, UNIX_DGRAM_PATH, sizeof(addr.sun_path) - 1);
    #####:  147:    bind(sock, (sockaddr*)&addr, sizeof(addr));
call    0 never executed
    #####:  148:    return sock;
        -:  149:}
        -:  150:
        -:  151:/**
        -:  152: * @brief Handles TCP command (e.g., "ADD OXYGEN 5").
        -:  153: * @param command The full command string.
        -:  154: */
function _Z18handle_tcp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 22 returned 100% blocks executed 83%
       22:  155:void handle_tcp_command(const string& command) {
       22:  156:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       22:  157:    string action, atom, amount_string;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  158:
       22:  159:    iss >> action >> atom >> amount_string;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
       22:  160:    transform(atom.begin(), atom.end(), atom.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  161:
       22:  162:    if (action != "ADD" || atom_inventory.find(atom) == atom_inventory.end() || iss.fail()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 86% (fallthrough)
branch  4 taken 14%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 79% (fallthrough)
branch 11 taken 21%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
branch 15 taken 7% (fallthrough)
branch 16 taken 93%
branch 17 taken 36% (fallthrough)
branch 18 taken 64%
        8:  163:        cerr << "Invalid TCP command!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        8:  164:        return;
        -:  165:    }
        -:  166:    // detect extra arguments
       14:  167:    string extra; 
call    0 returned 100%
       14:  168:    if (iss >> extra) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 7% (fallthrough)
branch  7 taken 93%
        1:  169:        cerr << "Invalid command: too many arguments!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  170:        return;
        -:  171:    }
        -:  172:
       13:  173:    add_atoms(atom, amount_string);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  174:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       50:  175:}
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
call    3 returned 100%
branch  4 taken 59% (fallthrough)
branch  5 taken 41%
call    6 returned 100%
branch  7 taken 59% (fallthrough)
branch  8 taken 41%
call    9 returned 100%
branch 10 taken 59% (fallthrough)
branch 11 taken 41%
call   12 returned 100%
branch 13 taken 59% (fallthrough)
branch 14 taken 41%
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  176:
        -:  177:/**
        -:  178: * @brief Handles UDP command to deliver molecules.
        -:  179: * @param command The full command string.
        -:  180: * @return Response to be sent back to the client.
        -:  181: */
function _Z18handle_udp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 19 returned 100% blocks executed 64%
       19:  182:string handle_udp_command(const string& command) {
       19:  183:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  184:    string action;
call    0 returned 100%
       19:  185:    iss >> action;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  186:
       19:  187:    if (action != "DELIVER") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 5% (fallthrough)
branch  4 taken 95%
        2:  188:        return "ERROR: Invalid command";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  189:    }
        -:  190:
       18:  191:    vector<string> tokens;
call    0 returned 100%
       18:  192:    string token;
call    0 returned 100%
       54:  193:    while (iss >> token) tokens.push_back(token);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
branch  9 taken 67%
branch 10 taken 33% (fallthrough)
        -:  194:
       24:  195:    if (tokens.size() < 2) return "ERROR: Invalid command format";
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  196:
        -:  197:  
       15:  198:    string count_str = tokens.back();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  199:
       15:  200:    if (!all_of(count_str.begin(), count_str.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 13% (fallthrough)
branch  6 taken 87%
        4:  201:        return "ERROR: Not a positive number";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  202:    }
        -:  203:
        -:  204:    unsigned long long count;
        -:  205:    try {
       13:  206:        count = stoull(count_str);
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8% (throw)
        1:  207:    } catch (const exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        1:  208:        return "ERROR: Conversion failed";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  209:    }
call    0 returned 100%
call    1 never executed
        -:  210:
       12:  211:    string molecule_name;
call    0 returned 100%
       28:  212:    for (size_t i = 0; i < tokens.size() - 1; ++i) {
call    0 returned 100%
branch  1 taken 57%
branch  2 taken 43% (fallthrough)
       16:  213:        if (!molecule_name.empty()) molecule_name += " ";
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
       16:  214:        molecule_name += tokens[i];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  215:    }
        -:  216:
       12:  217:    if (molecule_recipes.find(molecule_name) == molecule_recipes.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 42% (fallthrough)
branch  6 taken 58%
        5:  218:        return "ERROR: Unknown molecule '" + molecule_name + "'";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  219:    }
        -:  220:
        7:  221:    const auto& recipe = molecule_recipes[molecule_name];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  222:    map<string, unsigned long long> needed;
call    0 returned 100%
       24:  223:    for (const auto& [atom, per_mol] : recipe) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       17:  224:        needed[atom] += per_mol * count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  225:    }
        -:  226:
       24:  227:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 71%
branch  8 taken 29% (fallthrough)
       17:  228:        if (atom_inventory[atom] < need_count) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  229:            return "ERROR: Not enough atoms â€“ missing " + to_string(need_count - atom_inventory[atom]) + " " + atom;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
branch 13 never executed (fallthrough)
branch 14 never executed (throw)
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
        -:  230:        }
        -:  231:    }
        -:  232:
       24:  233:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       17:  234:        atom_inventory[atom] -= need_count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  235:    }
        -:  236:
        7:  237:    cout << "DELIVERED: " << count << " " << molecule_name << " molecules" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
        7:  238:    add_molecules_to_inventory(molecule_name, count);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  239:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        7:  240:    return "OK: Delivered " + to_string(count) + " " + molecule_name + " molecules";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
       19:  241:}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
        -:  242:
        -:  243:/**
        -:  244: * @brief Computes how many full drinks of a type can be prepared with available atoms.
        -:  245: * @param drink_name The name of the drink (e.g., "VODKA").
        -:  246: * @return Number of drinks that can be prepared.
        -:  247: */
function _Z19compute_drink_countRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 3 returned 100% blocks executed 63%
        3:  248:unsigned long long compute_drink_count(const string& drink_name) {
        -:  249:    // Required atom counts for one drink
        3:  250:    unsigned long long needed_carbon = 0;
        3:  251:    unsigned long long needed_hydrogen = 0;
        3:  252:    unsigned long long needed_oxygen = 0;
        -:  253:
        3:  254:    if (drink_name == "SOFT DRINK") {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        -:  255:        // Contains: WATER (H2O), CARBON DIOXIDE (CO2), GLUCOSE (C6H12O6)
        1:  256:        needed_carbon = 1 + 6;           // 1 from CO2, 6 from GLUCOSE
        1:  257:        needed_hydrogen = 2 + 12;        // 2 from WATER, 12 from GLUCOSE
        1:  258:        needed_oxygen = 1 + 2 + 6;       // 1 from WATER, 2 from CO2, 6 from GLUCOSE
        2:  259:    } else if (drink_name == "VODKA") {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  260:        // Contains: WATER, ALCOHOL (C2H6O), GLUCOSE
        1:  261:        needed_carbon = 2 + 6;           // 2 from ALCOHOL, 6 from GLUCOSE
        1:  262:        needed_hydrogen = 2 + 6 + 12;    // 2 from WATER, 6 from ALCOHOL, 12 from GLUCOSE
        1:  263:        needed_oxygen = 1 + 1 + 6;       // 1 from WATER, 1 from ALCOHOL, 6 from GLUCOSE
        1:  264:    } else if (drink_name == "CHAMPAGNE") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  265:        // Contains: WATER, CO2, ALCOHOL
        1:  266:        needed_carbon = 1 + 2;           // 1 from CO2, 2 from ALCOHOL
        1:  267:        needed_hydrogen = 2 + 6;         // 2 from WATER, 6 from ALCOHOL
        1:  268:        needed_oxygen = 1 + 2 + 1;       // 1 from WATER, 2 from CO2, 1 from ALCOHOL
        -:  269:    } else {
        -:  270:        // Drink not recognized
    #####:  271:        return 0;
        -:  272:    }
        -:  273:
        -:  274:    // Calculate how many full drinks can be made based on current atom inventory
        6:  275:    unsigned long long from_carbon = atom_inventory["CARBON"] / needed_carbon;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        6:  276:    unsigned long long from_hydrogen = atom_inventory["HYDROGEN"] / needed_hydrogen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        3:  277:    unsigned long long from_oxygen = atom_inventory["OXYGEN"] / needed_oxygen;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
call    8 never executed
        -:  278:
        -:  279:    // The limiting atom determines the maximum number of drinks possible
        3:  280:    return std::min({from_carbon, from_hydrogen, from_oxygen});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  281:}
        -:  282:
        -:  283:/**
        -:  284: * @brief Main entry point of the server. Handles TCP, UDP, UDS, and stdin.
        -:  285: */
function main called 17 returned 94% blocks executed 55%
       17:  286:int main(int argc, char* argv[]) {
       17:  287:    signal(SIGINT, handle_sigint);  // Catch Ctrl+C
call    0 returned 100%
       17:  288:    int tcp_port = -1, udp_port = -1;
       17:  289:    int timeout = -1;
        -:  290:    int opt;
       17:  291:    string stream_path, dgram_path;
call    0 returned 100%
call    1 returned 100%
        -:  292:
       50:  293:    while ((opt = getopt(argc, argv, "T:U:o:c:h:t:s:d:")) != -1) { // Parse command-line arguments
call    0 returned 100%
branch  1 taken 78%
branch  2 taken 22% (fallthrough)
       39:  294:        switch (opt) {
branch  0 taken 26%
branch  1 taken 23%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 8%
branch  6 taken 15%
branch  7 taken 13%
branch  8 taken 15%
       10:  295:            case 'T': tcp_port = atoi(optarg); break;
        9:  296:            case 'U': udp_port = atoi(optarg); break;
    #####:  297:            case 'o': add_atoms("OXYGEN", string(optarg)); break;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
    #####:  298:            case 'c': add_atoms("CARBON", string(optarg)); break;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
    #####:  299:            case 'h': add_atoms("HYDROGEN", string(optarg)); break;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
        9:  300:            case 't': timeout = set_timeout(string(optarg)); break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        6:  301:            case 's': stream_path = optarg; break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        5:  302:            case 'd': dgram_path = optarg; break;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        6:  303:            default:
        6:  304:                cerr << "Usage: ./drinks_bar -T <tcp_port> -U <udp_port> [-o num] [-c num] [-h num] [-t timeout]" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        6:  305:                return 1;
        -:  306:        }
        -:  307:    }
        -:  308:
       11:  309:    if (tcp_port == -1 || udp_port == -1) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        8:  310:        cerr << "ERROR: TCP and UDP ports are required (use -T and -U)" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        8:  311:        return 1;
        -:  312:    }
        -:  313:    
        -:  314:    fd_set master, read_fds;
       51:  315:    FD_ZERO(&master); // Clear fd set
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        3:  316:    int uds_stream_sock = -1, uds_dgram_sock = -1;
        3:  317:    int fdmax = STDIN_FILENO;
        -:  318:
        -:  319:    // Setup UDS stream socket if needed
        3:  320:    if (!stream_path.empty()) { 
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3:  321:        unlink(stream_path.c_str()); // Remove previous socket file
call    0 returned 100%
call    1 returned 100%
        3:  322:        uds_stream_sock = socket(AF_UNIX, SOCK_STREAM, 0);
call    0 returned 100%
        3:  323:        sockaddr_un addr{};
        3:  324:        addr.sun_family = AF_UNIX;
        3:  325:        strncpy(addr.sun_path, stream_path.c_str(), sizeof(addr.sun_path) - 1);
call    0 returned 100%
        3:  326:        bind(uds_stream_sock, (sockaddr*)&addr, sizeof(addr));
call    0 returned 100%
        3:  327:        listen(uds_stream_sock, 5);
call    0 returned 100%
        3:  328:        if (uds_stream_sock != -1) FD_SET(uds_stream_sock, &master);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       3*:  329:        if (uds_dgram_sock != -1) FD_SET(uds_dgram_sock, &master);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  330:
        3:  331:        fdmax = max(fdmax, uds_stream_sock);
call    0 returned 100%
        3:  332:        cout << "Listening on UDS stream: " << stream_path << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  333:    }
        -:  334:
        -:  335:    // Setup UDS datagram socket if needed
        3:  336:    if (!dgram_path.empty()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3:  337:        unlink(dgram_path.c_str());
call    0 returned 100%
call    1 returned 100%
        3:  338:        uds_dgram_sock = socket(AF_UNIX, SOCK_DGRAM, 0);
call    0 returned 100%
        3:  339:        sockaddr_un addr{};
        3:  340:        addr.sun_family = AF_UNIX;
        3:  341:        strncpy(addr.sun_path, dgram_path.c_str(), sizeof(addr.sun_path) - 1);
call    0 returned 100%
        3:  342:        bind(uds_dgram_sock, (sockaddr*)&addr, sizeof(addr));
call    0 returned 100%
        3:  343:        if (uds_stream_sock != -1) fdmax = max(fdmax, uds_stream_sock);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        3:  344:        if (uds_dgram_sock != -1) fdmax = max(fdmax, uds_dgram_sock);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  345:
        3:  346:        fdmax = max(fdmax, uds_dgram_sock);
call    0 returned 100%
        3:  347:        cout << "Listening on UDS datagram: " << dgram_path << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  348:    }
        -:  349:
        -:  350:    // Setup TCP socket
        3:  351:    int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
call    0 returned 100%
        3:  352:    sockaddr_in tcp_addr{};
        3:  353:    tcp_addr.sin_family = AF_INET;
        3:  354:    tcp_addr.sin_addr.s_addr = INADDR_ANY;
        3:  355:    tcp_addr.sin_port = htons(tcp_port);
        3:  356:    if (bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr)) < 0) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1:  357:    perror("bind TCP");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  358:    return 1;
        -:  359:    }
        2:  360:    listen(tcp_sock, 5);
call    0 returned 100%
        -:  361:
        -:  362:    // Setup UDP socket
        2:  363:    int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
call    0 returned 100%
        2:  364:    sockaddr_in udp_addr{};
        2:  365:    udp_addr.sin_family = AF_INET;
        2:  366:    udp_addr.sin_addr.s_addr = INADDR_ANY;
        2:  367:    udp_addr.sin_port = htons(udp_port);
        2:  368:    if(bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr)) < 0){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  369:        perror("bind UDP");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  370:        return 1;
        -:  371:    }
        -:  372:
        2:  373:    cout << "bar_drinks running on TCP port " << tcp_port
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  374:         << " and UDP port " << udp_port << "..." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        -:  375:    
        2:  376:    print_inventory(); // Display starting inventory
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  377:
        -:  378:    // Add all listening sockets to the master set
        2:  379:    FD_SET(tcp_sock, &master);
        2:  380:    FD_SET(udp_sock, &master);
        2:  381:    FD_SET(STDIN_FILENO, &master);
        2:  382:    fdmax = max({tcp_sock, udp_sock, STDIN_FILENO});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:  383:    FD_SET(uds_stream_sock, &master);
        2:  384:    FD_SET(uds_dgram_sock, &master);
        2:  385:    fdmax = max({fdmax, uds_stream_sock, uds_dgram_sock});
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  386:
        -:  387:
        2:  388:    timeval* timeout_ptr = nullptr;
        2:  389:    timeval timeout_val{};
        2:  390:    if (timeout > 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  391:        timeout_val.tv_sec = timeout;
        1:  392:        timeout_val.tv_usec = 0;
        1:  393:        timeout_ptr = &timeout_val;
        -:  394:    }
        2:  395:    vector<int> clients;
call    0 returned 100%
call    1 never executed
        -:  396:
        -:  397:    // === Event Loop ===
        -:  398:    while (true) {
       57:  399:        read_fds = master;
       57:  400:        int activity = select(fdmax + 1, &read_fds, nullptr, nullptr, timeout_ptr);
call    0 returned 98%
branch  1 taken 98% (fallthrough)
branch  2 taken 0% (throw)
       56:  401:        if (activity < 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  402:            perror("select");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  403:            break;
       56:  404:        } else if (activity == 0) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        1:  405:            cout << "Timeout reached with no activity. Server exiting." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:  406:            break;
        -:  407:        }
        -:  408:
      495:  409:        for (int i = 0; i <= fdmax; ++i) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
      440:  410:            if (!FD_ISSET(i, &read_fds)) continue;
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
       55:  411:                        else if (i == uds_stream_sock) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        1:  412:                int newfd = accept(uds_stream_sock, nullptr, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  413:                if (newfd >= 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  414:                    FD_SET(newfd, &master);
        1:  415:                    if (newfd > fdmax) fdmax = newfd;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  416:                    clients.push_back(newfd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  417:                    if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  418:                        timeout_val.tv_sec = timeout;
    #####:  419:                        timeout_val.tv_usec = 0;
    #####:  420:                        timeout_ptr = &timeout_val;
        -:  421:                    }
        -:  422:                }
       54:  423:            } else if (i == uds_dgram_sock) {
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
       19:  424:                char buf[1024] = {0};
       19:  425:                sockaddr_un client_addr{};
       19:  426:                socklen_t len = sizeof(client_addr);
       19:  427:                int n = recvfrom(uds_dgram_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  428:                if (n > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       19:  429:                    string response = handle_udp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       19:  430:                    if (response.rfind("ERROR", 0) == 0) cerr << response << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 63% (fallthrough)
branch  4 taken 37%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0% (throw)
       19:  431:                    sendto(uds_dgram_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       19:  432:                    if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:                        timeout_val.tv_sec = timeout;
    #####:  434:                        timeout_val.tv_usec = 0;
    #####:  435:                        timeout_ptr = &timeout_val;
        -:  436:                    }
       19:  437:                }
call    0 returned 100%
call    1 never executed
        -:  438:            }
        -:  439:
       35:  440:            else if (i == tcp_sock) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  441:                int newfd = accept(tcp_sock, nullptr, nullptr);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  442:                FD_SET(newfd, &master);
    #####:  443:                if (newfd > fdmax) fdmax = newfd;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  444:                clients.push_back(newfd);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  445:                if (timeout > 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  446:                timeout_val.tv_sec = timeout;
    #####:  447:                timeout_val.tv_usec = 0;
    #####:  448:                timeout_ptr = &timeout_val;
        -:  449:                }
       35:  450:            } else if (i == udp_sock) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  451:                char buf[1024] = {0};
    #####:  452:                sockaddr_in client_addr{};
    #####:  453:                socklen_t len = sizeof(client_addr);
    #####:  454:                int n = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  455:                if (n > 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  456:                    string response = handle_udp_command(string(buf));
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
    #####:  457:                    if (response.rfind("ERROR", 0) == 0) cerr << response << endl;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
branch  3 never executed (fallthrough)
branch  4 never executed
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
call    8 never executed
branch  9 never executed (fallthrough)
branch 10 never executed (throw)
    #####:  458:                    sendto(udp_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  459:                    if (timeout > 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  460:                    timeout_val.tv_sec = timeout;
    #####:  461:                    timeout_val.tv_usec = 0;
    #####:  462:                    timeout_ptr = &timeout_val;
        -:  463:                    }
    #####:  464:                }
call    0 never executed
call    1 never executed
       35:  465:            } else if (i == STDIN_FILENO) {
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
       12:  466:                string line;
call    0 returned 100%
       12:  467:                getline(cin, line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  468:                transform(line.begin(), line.end(), line.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       12:  469:                istringstream iss(line);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  470:                string command, drink;
call    0 returned 100%
call    1 returned 100%
       12:  471:                iss >> command;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  472:                getline(iss, drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  473:                drink.erase(0, drink.find_first_not_of(" "));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
       12:  474:                transform(command.begin(), command.end(), command.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       12:  475:                transform(drink.begin(), drink.end(), drink.begin(), ::toupper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       12:  476:                if (command == "GEN" && drink_recipes.find(drink) != drink_recipes.end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 58% (fallthrough)
branch  4 taken 42%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 43% (fallthrough)
branch 11 taken 57%
branch 12 taken 25% (fallthrough)
branch 13 taken 75%
        3:  477:                    unsigned long long count = compute_drink_count(drink);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  478:                    cout << "Can prepare " << count << " " << drink << " drinks" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0% (throw)
        -:  479:                } else {
        9:  480:                    cout << "Unknown drink command: " << line << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:  481:                }
       12:  482:                if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  483:                timeout_val.tv_sec = timeout;
    #####:  484:                timeout_val.tv_usec = 0;
    #####:  485:                timeout_ptr = &timeout_val;
        -:  486:                }
       12:  487:            } else {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
       23:  488:                char buf[1024] = {0};
       23:  489:                int n = recv(i, buf, sizeof(buf) - 1, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       23:  490:                if (n <= 0) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        1:  491:                    close(i);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  492:                    FD_CLR(i, &master);
        -:  493:                } else {
       22:  494:                    handle_tcp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       22:  495:                    if (timeout > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  496:                    timeout_val.tv_sec = timeout;
    #####:  497:                    timeout_val.tv_usec = 0;
    #####:  498:                    timeout_ptr = &timeout_val;
        -:  499:                    }
        -:  500:                }
        -:  501:            }
        -:  502:        }
       55:  503:    }
        -:  504:    // Cleanup
        1:  505:    if (uds_stream_sock != -1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  506:    close(uds_stream_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  507:    unlink(stream_path.c_str());
call    0 returned 100%
call    1 returned 100%
        -:  508:    }
        1:  509:    if (uds_dgram_sock != -1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  510:        close(uds_dgram_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  511:        unlink(dgram_path.c_str());
call    0 returned 100%
call    1 returned 100%
        -:  512:    }
        -:  513:
        1:  514:    close(tcp_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  515:    close(udp_sock);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  516:
        -:  517:
        1:  518:    return 0;
call    0 returned 100%
       16:  519:}
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
