        -:    0:Source:molecule_supplier.cpp
        -:    0:Graph:molecule_supplier.gcno
        -:    0:Data:molecule_supplier.gcda
        -:    0:Runs:5
        -:    1:#include <iostream>
        -:    2:#include <string>
        -:    3:#include <map>
        -:    4:#include <vector>
        -:    5:#include <sstream>
        -:    6:#include <algorithm>
        -:    7:#include <unistd.h>
        -:    8:#include <cstring>
        -:    9:#include <netinet/in.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/select.h>
        -:   12:#include <csignal>  // for the signals 
        -:   13:#include <cstdlib>  // exit()
        -:   14:#define MAX_VALUE 1000000000000000000
        -:   15:using namespace std;
        -:   16:
        -:   17:/**
        -:   18: * @brief Handles SIGINT (Ctrl+C) signal and exits cleanly.
        -:   19: */
function _Z13handle_siginti called 1 returned 0% blocks executed 100%
        1:   20:void handle_sigint([[maybe_unused]] int sig) {
        1:   21:    cout << "\nðŸ“¤ Caught SIGINT (Ctrl+C). Exiting cleanly...\n";
call    0 returned 100%
        1:   22:    exit(0);  // makes the .gcda 
        -:   23:}
        -:   24:
        -:   25:// Global atom inventory, initialized to 0 for each atom type
        -:   26:map<string, unsigned long long> atom_inventory = {
        -:   27:    {"CARBON", 0}, {"OXYGEN", 0}, {"HYDROGEN", 0}
        -:   28:};
        -:   29:
        -:   30:// Recipe book for building molecules from atoms
        -:   31:map<string, map<string, int>> molecule_recipes = {
        -:   32:    {"WATER", {{"HYDROGEN", 2}, {"OXYGEN", 1}}},
        -:   33:    {"CARBON DIOXIDE", {{"CARBON", 1}, {"OXYGEN", 2}}},
        -:   34:    {"ALCOHOL", {{"CARBON", 2}, {"HYDROGEN", 6}, {"OXYGEN", 1}}},
        -:   35:    {"GLUCOSE", {{"CARBON", 6}, {"HYDROGEN", 12}, {"OXYGEN", 6}}}
        -:   36:};
        -:   37:
        -:   38:/** 
        -:   39: * Prints the current atom inventory to the console.
        -:   40: */
function _Z15print_inventoryv called 20 returned 100% blocks executed 61%
       20:   41:void print_inventory() {
       40:   42:    cout << "CARBON: " << atom_inventory["CARBON"]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0% (throw)
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0% (throw)
call   10 never executed
       60:   43:         << ", OXYGEN: " << atom_inventory["OXYGEN"]
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
call   13 never executed
       60:   44:         << ", HYDROGEN: " << atom_inventory["HYDROGEN"] << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 never executed
       20:   45:}
        -:   46:
        -:   47:/**
        -:   48: * Adds a specified amount of atoms to the inventory.
        -:   49: * Validates the input and ensures inventory won't overflow.
        -:   50: */
function _Z9add_atomsRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_ called 12 returned 100% blocks executed 92%
       12:   51:void add_atoms(const string& atom_type, const string& amount_string) {
       12:   52:    if (!all_of(amount_string.begin(), amount_string.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 25% (fallthrough)
branch  4 taken 75%
        3:   53:        cerr << "Invalid command: amount must be a positive number!" << endl;
call    0 returned 100%
call    1 returned 100%
        3:   54:        return;
        -:   55:    }
        -:   56:
        -:   57:    try {
        9:   58:        unsigned long long amount = stoull(amount_string);  // Convert string to unsigned long long
call    0 returned 100%
branch  1 taken 78% (fallthrough)
branch  2 taken 22% (throw)
        7:   59:        if (atom_inventory[atom_type] + amount > MAX_VALUE) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
        1:   60:            cerr << "Invalid command: not enough place for the atoms!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:   61:            return;
        -:   62:        }
        -:   63:
        6:   64:        atom_inventory[atom_type] += amount;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        2:   65:    } catch (const exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        2:   66:        cerr << "Error converting number" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:   67:    }
call    0 returned 100%
call    1 never executed
        -:   68:}
        -:   69:
        -:   70:/**
        -:   71: * Handles TCP commands from clients (e.g., "ADD OXYGEN 50").
        -:   72: */
function _Z18handle_tcp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 22 returned 100% blocks executed 83%
       22:   73:void handle_tcp_command(const string& command) {
       22:   74:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       22:   75:    string action, atom_type, amount_string;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   76:  
       22:   77:    iss >> action >> atom_type >> amount_string;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
        -:   78:    
       22:   79:    if (action != "ADD" || iss.fail()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 82% (fallthrough)
branch  4 taken 18%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
branch  8 taken 17% (fallthrough)
branch  9 taken 83%
branch 10 taken 32% (fallthrough)
branch 11 taken 68%
        7:   80:        cerr << "Invalid command!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        7:   81:        return;
        -:   82:    }
        -:   83:
        -:   84:    // detect extra arguments
       15:   85:    string extra; 
call    0 returned 100%
       15:   86:    if (iss >> extra) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 7% (fallthrough)
branch  7 taken 93%
        1:   87:        cerr << "Invalid command: too many arguments!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        1:   88:        return;
        -:   89:    }
        -:   90:
       14:   91:    transform(atom_type.begin(), atom_type.end(), atom_type.begin(), ::toupper); // Convert atom name to uppercase
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:   92:
       14:   93:    if (atom_inventory.find(atom_type) != atom_inventory.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 86% (fallthrough)
branch  6 taken 14%
       12:   94:        add_atoms(atom_type, amount_string);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:   95:        print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   96:    } else {
        2:   97:        cerr << "Unknown atom type!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:   98:    }
       47:   99:}
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
call    3 returned 100%
branch  4 taken 64% (fallthrough)
branch  5 taken 36%
call    6 returned 100%
branch  7 taken 64% (fallthrough)
branch  8 taken 36%
call    9 returned 100%
branch 10 taken 64% (fallthrough)
branch 11 taken 36%
call   12 returned 100%
branch 13 taken 64% (fallthrough)
branch 14 taken 36%
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  100:
        -:  101:/**
        -:  102: * Handles UDP commands for delivering molecules.
        -:  103: * Validates input and updates inventory if enough atoms are available.
        -:  104: */
function _Z18handle_udp_commandRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 19 returned 100% blocks executed 50%
       19:  105:string handle_udp_command(const string& command) {
       19:  106:    istringstream iss(command);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  107:    string action;
call    0 returned 100%
       19:  108:    iss >> action;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  109:
       19:  110:    if (action != "DELIVER") {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 5% (fallthrough)
branch  4 taken 95%
        1:  111:        cerr << "Invalid UDP command!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        2:  112:        return "ERROR: Invalid command";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  113:    }
        -:  114:
       18:  115:    vector<string> tokens;
call    0 returned 100%
       18:  116:    string token;
call    0 returned 100%
       55:  117:    while (iss >> token) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 67%
branch  7 taken 33% (fallthrough)
       37:  118:        tokens.push_back(token);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  119:    }
        -:  120:
       18:  121:    if (tokens.size() < 2) {
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
        2:  122:        cerr << "Invalid UDP command format!" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        4:  123:        return "ERROR: Invalid command format";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  124:    }
        -:  125:
       16:  126:    string count_str = tokens.back();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  127:
       16:  128:    if (!all_of(count_str.begin(), count_str.end(), ::isdigit)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
branch  5 taken 12% (fallthrough)
branch  6 taken 88%
        4:  129:        return "ERROR: Not a positive number";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  130:    }
        -:  131:
        -:  132:    unsigned long long count;
        -:  133:    try {
       14:  134:        count = stoull(count_str);
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7% (throw)
        1:  135:    } catch (const exception& e) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        1:  136:        return "ERROR: Conversion failed";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  137:    }
call    0 returned 100%
call    1 never executed
        -:  138:
        -:  139:    // Reconstruct molecule name (excluding atom if provided)
       13:  140:    string molecule_name;
call    0 returned 100%
       30:  141:    for (size_t i = 0; i < tokens.size() - 1; ++i) {
call    0 returned 100%
branch  1 taken 57%
branch  2 taken 43% (fallthrough)
       17:  142:        if (!molecule_name.empty()) molecule_name += " ";
call    0 returned 100%
branch  1 taken 24% (fallthrough)
branch  2 taken 76%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
       17:  143:        molecule_name += tokens[i];
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
        -:  144:    }
        -:  145:
       13:  146:    string atom_name = "";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  147:    string real_molecule = molecule_name;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       13:  148:    if (tokens.size() > 3) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  149:        atom_name = tokens[0];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
    #####:  150:        real_molecule = molecule_name.substr(atom_name.size() + 1);  // Skip atom name
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
call    5 never executed
        -:  151:    }
        -:  152:
       13:  153:    if (molecule_recipes.find(real_molecule) == molecule_recipes.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0% (throw)
call    4 returned 100%
branch  5 taken 38% (fallthrough)
branch  6 taken 62%
        5:  154:        return "ERROR: Unknown molecule '" + real_molecule + "'";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  155:    }
        -:  156:
        8:  157:    const auto& recipe = molecule_recipes[real_molecule];
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:  158:
        8:  159:    map<string, unsigned long long> needed;
call    0 returned 100%
       28:  160:    for (const auto& [atom, per_mol] : recipe) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       20:  161:        needed[atom] += per_mol * count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  162:    }
        -:  163:
        8:  164:    if (!atom_name.empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  165:        string upper_atom = atom_name;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  166:        transform(upper_atom.begin(), upper_atom.end(), upper_atom.begin(), ::toupper);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  167:        if (atom_inventory.find(upper_atom) == atom_inventory.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed
    #####:  168:            return "ERROR: Invalid atom '" + upper_atom + "'";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
        -:  169:        }
    #####:  170:        needed[upper_atom] += count;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  171:    }
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
call    3 never executed
        -:  172:
        -:  173:    // Check for missing atoms
        8:  174:    vector<string> missing_atoms;
call    0 returned 100%
       28:  175:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 71%
branch  8 taken 29% (fallthrough)
       20:  176:        if (atom_inventory[atom] < need_count) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  177:            unsigned long long missing = need_count - atom_inventory[atom];
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  178:            missing_atoms.push_back(to_string(missing) + " " + atom);
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
        -:  179:        }
        -:  180:    }
        -:  181:
        8:  182:    if (!missing_atoms.empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  183:        string error = "ERROR: Not enough atoms â€“ missing ";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  184:        for (size_t i = 0; i < missing_atoms.size(); ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed (fallthrough)
    #####:  185:            if (i > 0) error += ", ";
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
    #####:  186:            error += missing_atoms[i];
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
        -:  187:        }
    #####:  188:        return error;
call    0 never executed
    #####:  189:    }
call    0 never executed
call    1 never executed
        -:  190:
        -:  191:    // Deduct required atoms
       28:  192:    for (const auto& [atom, need_count] : needed) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 71%
branch  7 taken 29% (fallthrough)
       20:  193:        atom_inventory[atom] -= need_count;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
        -:  194:    }
        -:  195:
        8:  196:    print_inventory();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  197:    return "OK: Delivered " + to_string(count) + " " + molecule_name + " molecules";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
       19:  198:}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
        -:  199:
        -:  200:/**
        -:  201: * Main server loop: listens for TCP and UDP connections,
        -:  202: * handles incoming commands from clients.
        -:  203: */
function main called 5 returned 80% blocks executed 76%
        5:  204:int main(int argc, char* argv[]) {
        5:  205:    signal(SIGINT, handle_sigint);  // Catch Ctrl+C
call    0 returned 100%
        5:  206:    if (argc != 3) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        4:  207:        cerr << "Usage: " << argv[0] << " <TCP_PORT> <UDP_PORT>" << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
        4:  208:        return 1;
        -:  209:    }
        -:  210:
        1:  211:    int tcp_port = atoi(argv[1]);
        1:  212:    int udp_port = atoi(argv[2]);
        -:  213:
        -:  214:    // Create TCP socket
        1:  215:    int tcp_sock = socket(AF_INET, SOCK_STREAM, 0);
call    0 returned 100%
        1:  216:    sockaddr_in tcp_addr {};
        1:  217:    tcp_addr.sin_family = AF_INET;
        1:  218:    tcp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  219:    tcp_addr.sin_port = htons(tcp_port);
        1:  220:    bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr));
call    0 returned 100%
        1:  221:    listen(tcp_sock, 5);
call    0 returned 100%
        -:  222:
        -:  223:    // Create UDP socket
        1:  224:    int udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
call    0 returned 100%
        1:  225:    sockaddr_in udp_addr {};
        1:  226:    udp_addr.sin_family = AF_INET;
        1:  227:    udp_addr.sin_addr.s_addr = INADDR_ANY;
        1:  228:    udp_addr.sin_port = htons(udp_port);
        1:  229:    bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr));
call    0 returned 100%
        -:  230:
        1:  231:    cout << "Server listening on TCP port " << tcp_port
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        1:  232:         << " and UDP port " << udp_port << "..." << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0% (throw)
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0% (throw)
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0% (throw)
        -:  233:
        -:  234:    fd_set master, read_fds;
       17:  235:    FD_ZERO(&master);
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        1:  236:    FD_SET(tcp_sock, &master);
        1:  237:    FD_SET(udp_sock, &master);
        1:  238:    int fdmax = max(tcp_sock, udp_sock);
call    0 returned 100%
        -:  239:
        1:  240:    vector<int> clients;
call    0 returned 100%
        -:  241:
        -:  242:    while (true) {
       48:  243:        read_fds = master;
       48:  244:        if (select(fdmax + 1, &read_fds, nullptr, nullptr, nullptr) < 0) {
call    0 returned 98%
branch  1 taken 98% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  245:            perror("select");
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:  246:            break;
        -:  247:        }
        -:  248:
      329:  249:        for (int i = 0; i <= fdmax; ++i) {
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
      282:  250:            if (!FD_ISSET(i, &read_fds)) continue;
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  251:
       47:  252:            if (i == tcp_sock) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  253:                // New TCP connection
        3:  254:                int newfd = accept(tcp_sock, nullptr, nullptr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  255:                FD_SET(newfd, &master);
        3:  256:                if (newfd > fdmax) fdmax = newfd;
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        3:  257:                clients.push_back(newfd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       44:  258:            } else if (i == udp_sock) {
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
        -:  259:                // Incoming UDP message
       19:  260:                char buf[1024] = {0};
       19:  261:                sockaddr_in client_addr {};
       19:  262:                socklen_t len = sizeof(client_addr);
       19:  263:                int n = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&client_addr, &len);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       19:  264:                if (n > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       19:  265:                    string response = handle_udp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
       19:  266:                    if (response.rfind("ERROR", 0) == 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
branch  3 taken 58% (fallthrough)
branch  4 taken 42%
       11:  267:                        cerr << response << endl;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  268:                    } else {
        8:  269:                        cout << response << endl;  // Success output
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        -:  270:                    }
        -:  271:
       19:  272:                    sendto(udp_sock, response.c_str(), response.size(), 0, (sockaddr*)&client_addr, len);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0% (throw)
       19:  273:                }
call    0 returned 100%
call    1 never executed
        -:  274:
        -:  275:            } else {
        -:  276:                // Incoming TCP data
       25:  277:                char buf[1024] = {0};
       25:  278:                int n = recv(i, buf, sizeof(buf) - 1, 0);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       25:  279:                if (n <= 0) {
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        3:  280:                    close(i);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        3:  281:                    FD_CLR(i, &master);
        -:  282:                } else {
       44:  283:                    handle_tcp_command(string(buf));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
call    6 returned 100%
call    7 never executed
        -:  284:                }
        -:  285:            }
        -:  286:        }
       47:  287:    }
        -:  288:
    #####:  289:    return 0;
    #####:  290:}
call    0 never executed
call    1 never executed
